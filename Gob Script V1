// Global variables for script control
let active = true; // Toggle state for the original script
let firstScriptActive = false;
let secondScriptActive = true; // Auto-respawn enabled by default
let bombSpamActive = false;
let bombSpamInterval = null;
let moveTimeout = null; // Only declared once now
let currentDirection = null; // Only declared once now
let respawnTimer = null;
let scoreBoardInterval = null;

// Define key codes (only declared once)
const ee = {
    up: { keyCode: 87, key: "w" },
    left: { keyCode: 65, key: "a" },
    down: { keyCode: 83, key: "s" },
    right: { keyCode: 68, key: "d" },
    upLeft: { keys: [87, 65] },
    upRight: { keys: [87, 68] },
    downLeft: { keys: [83, 65] },
    downRight: { keys: [83, 68] }
};

// First Script: Character Movement & Bomb Placement
function simulateKeyDown(direction) {
    if (direction.keys) {
        direction.keys.forEach(keyCode => {
            let event = new KeyboardEvent("keydown", { keyCode: keyCode });
            document.dispatchEvent(event);
        });
    } else {
        let event = new KeyboardEvent("keydown", { keyCode: direction.keyCode, key: direction.key });
        document.dispatchEvent(event);
    }
}

function simulateKeyUp(direction) {
    if (direction.keys) {
        direction.keys.forEach(keyCode => {
            let event = new KeyboardEvent("keyup", { keyCode: keyCode });
            document.dispatchEvent(event);
        });
    } else {
        let event = new KeyboardEvent("keyup", { keyCode: direction.keyCode, key: direction.key });
        document.dispatchEvent(event);
    }
}

// Function to simulate placing a bomb (pressing "K")
function placeBomb() {
    var bombKeyEvent = new KeyboardEvent("keydown", { keyCode: 75, key: "K" });
    document.dispatchEvent(bombKeyEvent);
    setTimeout(() => {
        var bombKeyReleaseEvent = new KeyboardEvent("keyup", { keyCode: 75, key: "K" });
        document.dispatchEvent(bombKeyReleaseEvent);
    }, 100);
}

function getRandomDirection() {
    const directions = [ee.right, ee.down, ee.left, ee.up, ee.upLeft, ee.upRight, ee.downLeft, ee.downRight];
    return directions[Math.floor(Math.random() * directions.length)];
}

function getRandomDelay(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
}

function getRandomPause(min, max) {
    return Math.random() * (max - min) + min;
}

// Function to simulate random direction presses (W, A, S, D) for 50ms during pause
function randomDirectionPress() {
    const directions = [ee.up, ee.left, ee.down, ee.right];
    const direction = directions[Math.floor(Math.random() * directions.length)];
    // Simulate pressing a random direction key for 50ms
    simulateKeyDown(direction);
    setTimeout(() => {
        simulateKeyUp(direction); // Stop the key press after 50ms
    }, 50);
}

// Function to Move Character
function moveCharacter() {
    if (!firstScriptActive) return;
    const direction = getRandomDirection();
    const delay = getRandomDelay(900, 1500); // Longer motion time
    const pauseTime = getRandomPause(125, 1000);
    // If there's an ongoing movement, stop it before starting a new one
    if (moveTimeout) {
        clearTimeout(moveTimeout); // Clear the previous movement timeout
    }
    // Stop the current direction if it's moving
    if (currentDirection) {
        simulateKeyUp(currentDirection);
    }
    // Place a bomb before changing direction
    placeBomb();
    // Start the new movement direction after bomb placement
    currentDirection = direction;
    setTimeout(() => {
        simulateKeyDown(direction);
        moveTimeout = setTimeout(() => {
            simulateKeyUp(direction); // Stop the current movement after delay
            
            // Simulate random direction press during the pause (50ms)
            randomDirectionPress();
            
            setTimeout(moveCharacter, pauseTime); // Pause before next movement
        }, delay);
    }, 100); // Wait 100ms for bomb placement before moving
}

function simulateSpaceKeyPress() {
    if (!firstScriptActive) return;
    var spaceKeyEvent = new KeyboardEvent("keydown", { keyCode: 32, key: " " });
    document.dispatchEvent(spaceKeyEvent);
    setTimeout(() => {
        var spaceKeyReleaseEvent = new KeyboardEvent("keyup", { keyCode: 32, key: " " });
        document.dispatchEvent(spaceKeyReleaseEvent);
    }, 100);
}

// Second Script: Auto Respawn and R key press
function startAutoRespawn() {
    // Clear any existing interval first to prevent multiple instances
    if (scoreBoardInterval) {
        clearInterval(scoreBoardInterval);
    }
    
    scoreBoardInterval = setInterval(() => {
        if (!secondScriptActive) return;
        
        const scoreboard = document.getElementById("scoreboard-new");
        if (scoreboard && scoreboard.offsetParent === null) {
            // not visible
            return;
        }
        
        const respawnButton = [...document.getElementsByTagName("button")]
            .filter(b => b.innerText.indexOf("Respawn [Space]") === 0)[0];
        
        if (respawnButton) {
            // Clear any existing timer
            if (respawnTimer) clearTimeout(respawnTimer);
            
            // Click the respawn button
            respawnButton.click();
            
            // Set timer to press R after respawn
            respawnTimer = setTimeout(() => {
                console.log("Pressing R key");
                
                // Simulate R keypress
                const rKeyDown = new KeyboardEvent('keydown', { key: 'r', code: 'KeyR', keyCode: 82, which: 82 });
                document.dispatchEvent(rKeyDown);
                
                // Release R key after a short delay
                setTimeout(() => {
                    const rKeyUp = new KeyboardEvent('keyup', { key: 'r', code: 'KeyR', keyCode: 82, which: 82 });
                    document.dispatchEvent(rKeyUp);
                }, 50);
            }, 1000); // 1 second after respawn
        }
    }, 100);
}

// Third Script: Bomb Spam when C is held
function startBombSpam() {
    // If an interval is already running, don't create a new one
    if (bombSpamInterval) return;
    
    // Create a rapid interval to spam bombs (K key)
    bombSpamInterval = setInterval(() => {
        if (bombSpamActive) {
            // Simulate K keypress (place bomb) as fast as possible
            var bombKeyEvent = new KeyboardEvent("keydown", { keyCode: 75, key: "k" });
            document.dispatchEvent(bombKeyEvent);
            
            // Release K key immediately
            setTimeout(() => {
                var bombKeyReleaseEvent = new KeyboardEvent("keyup", { keyCode: 75, key: "k" });
                document.dispatchEvent(bombKeyReleaseEvent);
            }, 10); // Very short delay for rapid spam
        }
    }, 20); // 20ms interval for very fast bomb spam (close to 50 times per second)
}

// Stop bomb spam
function stopBombSpam() {
    if (bombSpamInterval) {
        clearInterval(bombSpamInterval);
        bombSpamInterval = null;
    }
}

// Initialize auto-respawn (second script)
startAutoRespawn();
// Initialize bomb spam capability
startBombSpam();

// Toggle scripts with Z and X keys, hold C for bomb spam
document.addEventListener("keydown", (event) => {
    // Toggle first script (character movement) with Z key
    if (event.key === "z" || event.key === "Z") {
        firstScriptActive = !firstScriptActive;
        console.log(`движения бота + респавн ${firstScriptActive ? "enabled" : "disabled"}`);
        if (firstScriptActive) {
            moveCharacter(); // Restart movement loop when re-enabled
        }
    }
    
    // Toggle second script (auto-respawn) with X key
    if (event.key === "x" || event.key === "X") {
        secondScriptActive = !secondScriptActive;
        console.log(`тыква+респавн ${secondScriptActive ? "enabled" : "disabled"}`);
        if (secondScriptActive && !scoreBoardInterval) {
            startAutoRespawn(); // Restart auto-respawn if needed
        }
    }
    
    // Activate bomb spam when C is pressed
    if (event.key === "c" || event.key === "C") {
        bombSpamActive = true;
        console.log("авто цепь");
    }
});

// Stop bomb spam when C is released
document.addEventListener("keyup", (event) => {
    if (event.key === "c" || event.key === "C") {
        bombSpamActive = false;
        console.log("Bomb Spam deactivated");
    }
});

// Status log for initial state
console.log("Script loaded successfully!");
console.log("Движения бота +респавн(Z): " + (firstScriptActive ? "Enabled" : "Disabled"));
console.log("тыква + респавн (X): " + (secondScriptActive ? "Enabled" : "Disabled"));
console.log("Авто Цепь (hold C): Ready");
