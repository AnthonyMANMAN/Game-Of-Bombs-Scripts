

(function() {
    'use strict';

    // ‚ö†Ô∏è CONFIGURE THESE VALUES:
    const BOT_TOKEN = '7860609958:AAGSCiD2BFAfnUO6hWY-GW-VbKjVp2nifPY';  // Get from @BotFather
    const CHAT_ID = '-1002599400013';      // Your group chat ID (negative number)

    // Don't change anything below this line unless you know what you're doing
    
    let seenMessages = {}; // Use object instead of Map to avoid conflicts
    let observer = null;
    let currentServer = null;
    let isMonitoring = false;
    let serverCycleInterval = null;
    let serverList = ['US', 'EU', 'RU', 'BR', 'AU', 'JP'];
    let currentServerIndex = 0;
    let messageQueue = []; // Queue for processing messages in order
    let isProcessingQueue = false;
    let serverSwitchInProgress = false;

    function init() {
        console.log('üéÆ Game of Bombs Multi-Server Monitor Enhanced loaded');
        
        // Wait much longer to avoid conflicts with game initialization
        const startDelay = 8000; // 8 seconds
        
        // Wait for page to load completely AND game to initialize
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                console.log('üîÑ DOM loaded, waiting for game to initialize...');
                setTimeout(startMonitoring, startDelay);
            });
        } else {
            console.log('üîÑ Page already loaded, waiting for game to initialize...');
            setTimeout(startMonitoring, startDelay);
        }
    }

    function switchToServer(serverName) {
        // Don't switch if game seems to be having issues
        if (document.querySelector('body.error') || !document.getElementById('listChat')) {
            console.log('‚ö†Ô∏è Game appears to have issues, skipping server switch');
            return false;
        }

        const serverElements = document.querySelectorAll('#server-select .server-list li');
        for (const serverEl of serverElements) {
            const serverNameEl = serverEl.querySelector('h2');
            if (serverNameEl && serverNameEl.textContent.trim() === serverName) {
                console.log(`üîÑ Clicking to switch to ${serverName}...`);
                serverSwitchInProgress = true;
                
                // Use setTimeout to avoid blocking the main thread
                setTimeout(() => {
                    try {
                        serverEl.click();
                    } catch (error) {
                        console.error('‚ùå Error clicking server:', error);
                        serverSwitchInProgress = false;
                    }
                }, 100);
                
                return true;
            }
        }
        console.log(`‚ùå Server ${serverName} not found in list`);
        return false;
    }

    function startServerCycle() {
        if (serverCycleInterval) {
            clearInterval(serverCycleInterval);
        }

        console.log('üîÑ Starting automatic server cycling every 8 seconds...');
        
        serverCycleInterval = setInterval(() => {
            // Skip if already switching
            if (serverSwitchInProgress) {
                console.log('‚è≥ Server switch in progress, skipping cycle...');
                return;
            }

            const targetServer = serverList[currentServerIndex];
            console.log(`üéØ Attempting to switch to ${targetServer}...`);
            
            if (switchToServer(targetServer)) {
                // Wait longer and check multiple times for server detection
                let detectionAttempts = 0;
                const maxAttempts = 8;
                
                const checkServerDetection = () => {
                    detectionAttempts++;
                    const actualServer = getCurrentServer();
                    
                    console.log(`üîç Detection attempt ${detectionAttempts}: Found server "${actualServer}", Expected "${targetServer}"`);
                    
                    if (actualServer === targetServer) {
                        currentServer = actualServer;
                        console.log(`‚úÖ Successfully switched to ${actualServer}`);
                        serverSwitchInProgress = false;
                        
                        // Wait a bit more before checking existing messages to ensure chat is loaded
                        setTimeout(() => {
                            checkExistingMessages();
                        }, 1000);
                        
                        currentServerIndex = (currentServerIndex + 1) % serverList.length;
                    } else if (detectionAttempts < maxAttempts) {
                        // Try again in 400ms
                        setTimeout(checkServerDetection, 400);
                    } else {
                        console.log(`‚ö†Ô∏è Server detection failed after ${maxAttempts} attempts. Using "${actualServer}" as current server`);
                        currentServer = actualServer || targetServer;
                        serverSwitchInProgress = false;
                        currentServerIndex = (currentServerIndex + 1) % serverList.length;
                        
                        // Still check messages even if detection failed
                        setTimeout(() => {
                            checkExistingMessages();
                        }, 1000);
                    }
                };
                
                // Start detection after initial delay
                setTimeout(checkServerDetection, 800);
            } else {
                // If switch failed, try next server
                serverSwitchInProgress = false;
                currentServerIndex = (currentServerIndex + 1) % serverList.length;
            }
        }, 8000); // Switch every 8 seconds (increased from 5)
    }

    function getCurrentServer() {
        // Method 1: Check the dropdown button text (most reliable when visible)
        const serverButton = document.querySelector('.butt_left_menu.ng-binding .colorRed');
        if (serverButton) {
            const serverName = serverButton.textContent.trim();
            if (serverName && /^(US|EU|RU|BR|AU|JP)$/i.test(serverName)) {
                return serverName.toUpperCase();
            }
        }
        
        // Method 2: Check for selected server in the server list (most reliable)
        const selectedServer = document.querySelector('#server-select .server-list li.selected h2');
        if (selectedServer) {
            const serverName = selectedServer.textContent.trim();
            if (serverName && /^(US|EU|RU|BR|AU|JP)$/i.test(serverName)) {
                return serverName.toUpperCase();
            }
        }
        
        // Method 3: Check all server elements and find the one that looks selected
        const serverElements = document.querySelectorAll('#server-select .server-list li');
        for (const el of serverElements) {
            if (el.classList.contains('selected')) {
                const nameEl = el.querySelector('h2');
                if (nameEl) {
                    const serverName = nameEl.textContent.trim();
                    if (serverName && /^(US|EU|RU|BR|AU|JP)$/i.test(serverName)) {
                        return serverName.toUpperCase();
                    }
                }
            }
        }
        
        // Method 4: Check Angular scope (if accessible)
        try {
            const serverSelectEl = document.querySelector('#server-select');
            if (serverSelectEl && typeof angular !== 'undefined') {
                const scope = angular.element(serverSelectEl).scope();
                if (scope && scope.current && scope.current.server) {
                    const serverName = scope.current.server.name || scope.current.server.region;
                    if (serverName && /^(US|EU|RU|BR|AU|JP)$/i.test(serverName)) {
                        return serverName.toUpperCase();
                    }
                }
            }
        } catch (e) {
            // Angular might not be available, continue with other methods
        }
        
        // Method 5: Fallback to URL detection
        const url = window.location.href;
        const serverMatch = url.match(/server[=\/]?(\d+)/i);
        if (serverMatch) {
            return `Server${serverMatch[1]}`;
        }
        
        console.log('‚ö†Ô∏è Could not detect current server reliably');
        return 'Unknown';
    }

    function startMonitoring() {
        // Wait longer for game to fully initialize
        setTimeout(() => {
            // Check if game is properly loaded
            if (!document.getElementById('listChat') || !document.querySelector('#server-select')) {
                console.log('üîÑ Game not fully loaded, waiting longer...');
                setTimeout(startMonitoring, 5000);
                return;
            }

            // Check if Angular is available and initialized
            if (typeof angular === 'undefined') {
                console.log('üîÑ Angular not available, waiting...');
                setTimeout(startMonitoring, 3000);
                return;
            }

            const chatContainer = document.getElementById('listChat');
            if (!chatContainer) {
                console.log('Chat not found, retrying...');
                setTimeout(startMonitoring, 3000);
                return;
            }

            // Check if server list is available
            const serverListContainer = document.querySelector('#server-select .server-list');
            if (!serverListContainer) {
                console.log('Server list not found, retrying...');
                setTimeout(startMonitoring, 3000);
                return;
            }

            // Verify that game UI elements have proper content
            const serverElements = document.querySelectorAll('#server-select .server-list li');
            if (serverElements.length === 0) {
                console.log('No servers found in list, retrying...');
                setTimeout(startMonitoring, 3000);
                return;
            }

            // Get initial server
            currentServer = getCurrentServer();
            console.log(`üéÆ Starting on ${currentServer}`);
            
            // Stop previous observer if running
            if (observer) {
                observer.disconnect();
            }
            
            // Check existing messages after a delay
            setTimeout(() => {
                checkExistingMessages();
            }, 2000);
            
            // Start observer for chat with error handling
            try {
                observer = new MutationObserver(handleChatChanges);
                observer.observe(chatContainer, {
                    childList: true,
                    subtree: true
                });
                
                isMonitoring = true;
                console.log(`‚úÖ Started monitoring for SERVER messages`);
                
                // Start automatic server cycling
                setTimeout(() => {
                    startServerCycle();
                }, 3000);

            } catch (error) {
                console.error('‚ùå Error starting observer:', error);
                setTimeout(startMonitoring, 5000);
            }

        }, 6000); // Increased initial delay significantly
    }

    function checkExistingMessages() {
        const messages = document.querySelectorAll('#listChat li');
        console.log(`üîç Checking ${messages.length} existing messages on ${currentServer}`);
        
        // Process messages in order (oldest to newest)
        const messageArray = Array.from(messages);
        messageArray.forEach((message, index) => {
            // Add small delay between processing to maintain order
            setTimeout(() => {
                processMessage(message, true); // true indicates existing message
            }, index * 50); // 50ms delay between each message
        });
    }

    function handleChatChanges(mutations) {
        // Add try-catch to prevent errors from breaking the observer
        try {
            mutations.forEach(mutation => {
                if (mutation.type === 'childList') {
                    mutation.addedNodes.forEach(node => {
                        if (node.nodeType === Node.ELEMENT_NODE) {
                            // Add new messages to queue for ordered processing
                            messageQueue.push({
                                element: node,
                                timestamp: Date.now(),
                                isExisting: false
                            });
                            processMessageQueue();
                        }
                    });
                }
            });
        } catch (error) {
            console.error('‚ùå Error in handleChatChanges:', error);
        }
    }

    function processMessageQueue() {
        if (isProcessingQueue || messageQueue.length === 0) return;
        
        isProcessingQueue = true;
        
        // Process messages with small delays to maintain order
        const processNext = () => {
            if (messageQueue.length === 0) {
                isProcessingQueue = false;
                return;
            }
            
            const messageData = messageQueue.shift();
            processMessage(messageData.element, messageData.isExisting);
            
            // Small delay before processing next message
            setTimeout(processNext, 100);
        };
        
        processNext();
    }

    function processMessage(messageElement, isExisting = false) {
        const nicknameEl = messageElement.querySelector('.nickname');
        if (!nicknameEl || nicknameEl.textContent.trim() !== 'SERVER') return;

        const textEl = messageElement.querySelector('.text span.ng-binding.ng-scope');
        const timeEl = messageElement.querySelector('.time');
        
        if (!textEl || !timeEl) return;

        const messageText = textEl.textContent.trim();
        const timeText = timeEl.textContent.trim();
        
        // Double-check current server at message time for accuracy
        const messageTimeServer = getCurrentServer();
        const serverToUse = messageTimeServer !== 'Unknown' ? messageTimeServer : currentServer;
        
        // Create multiple identifiers for better duplicate detection
        const messageId = `${serverToUse}-${timeText}-${messageText}`;
        const globalMessageId = `${timeText}-${messageText}`; // Global ID across all servers
        const contentHash = btoa(messageText + timeText).substring(0, 16); // Content-based hash
        
        // Check if we've seen this message before (any of the identifiers)
        if (seenMessages[messageId] || 
            seenMessages[globalMessageId] || 
            seenMessages[contentHash]) {
            return; // Skip duplicate
        }

        // Store all identifiers to prevent duplicates
        seenMessages[messageId] = {
            server: serverToUse,
            time: timeText,
            message: messageText,
            timestamp: Date.now(),
            isExisting: isExisting
        };
        seenMessages[globalMessageId] = { duplicate: true };
        seenMessages[contentHash] = { duplicate: true };

        console.log(`üì® ${isExisting ? 'Found existing' : 'New'} SERVER message on ${serverToUse}: ${messageText}`);
        
        // Only send new messages immediately, delay existing messages slightly
        if (isExisting) {
            setTimeout(() => {
                sendToTelegram(messageText, timeText, serverToUse);
            }, 200);
        } else {
            sendToTelegram(messageText, timeText, serverToUse);
        }
        
        // Clean up old messages to prevent memory bloat
        const messageKeys = Object.keys(seenMessages);
        if (messageKeys.length > 3000) {
            const oldEntries = messageKeys
                .filter(key => seenMessages[key].timestamp && (Date.now() - seenMessages[key].timestamp) > 300000) // 5 minutes old
                .slice(0, 1000); // Remove oldest 1000
            
            oldEntries.forEach(key => delete seenMessages[key]);
            console.log(`üßπ Cleaned up ${oldEntries.length} old message records`);
        }
    }

    async function sendToTelegram(message, time, server) {
        if (!BOT_TOKEN || !CHAT_ID || BOT_TOKEN.includes('YOUR_') || CHAT_ID.includes('YOUR_')) {
            console.error('‚ùå Please configure BOT_TOKEN and CHAT_ID first!');
            return;
        }

        const telegramMessage = `üéÆ <b>Game of Bombs</b> - <code>${server}</code>\n‚è∞ ${time}\nüìù ${message}`;
        
        try {
            const response = await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/sendMessage`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    chat_id: CHAT_ID,
                    text: telegramMessage,
                    parse_mode: 'HTML'
                })
            });

            if (response.ok) {
                console.log(`‚úÖ Sent to Telegram [${server}]:`, message);
            } else {
                const error = await response.text();
                console.error('‚ùå Telegram API error:', error);
            }
        } catch (error) {
            console.error('‚ùå Network error:', error);
        }
    }

    // Start the monitor
    init();
    
    // Clean up on page unload
    window.addEventListener('beforeunload', () => {
        if (serverCycleInterval) {
            clearInterval(serverCycleInterval);
        }
        if (observer) {
            observer.disconnect();
        }
    });

})();
