// Addon - Movement with Bombs
// This addon implements random movement with bomb placement

// Feature-specific variables
let movementActive = false;
let moveTimeout = null;
let currentDirection = null;

// Initialize the movement addon
function initMovementAddon() {
    // Add status to UI
    addFeatureStatus('movement-status', 'Бот с Бомбами (Z)', movementActive);
    
    // Register event handlers
    document.addEventListener('keydown', handleMovementToggle);
    document.addEventListener('gamebot-emergency-release', handleEmergencyRelease);
    document.addEventListener('gamebot-unload', cleanupMovementAddon);
    document.addEventListener('gamebot-ui-reattached', reinitMovementStatus);
    document.addEventListener('gamebot-claim-keys-check', handleKeyClaim);
    
    logActivity("Movement with Bombs addon loaded");
}

// Reinitialize the status after UI reattach
function reinitMovementStatus() {
    addFeatureStatus('movement-status', 'Бот с Бомбами (Z)', movementActive);
}

// Handle emergency release event
function handleEmergencyRelease() {
    if (moveTimeout) {
        clearTimeout(moveTimeout);
        moveTimeout = null;
    }
    currentDirection = null;
}

// Handle key claim check - prevent false stuck key detection
function handleKeyClaim(event) {
    if (movementActive) {
        // Claim keys if our addon is using them
        event.detail.claimed = true;
    }
}

// Cleanup function for addon
function cleanupMovementAddon() {
    if (moveTimeout) {
        clearTimeout(moveTimeout);
        moveTimeout = null;
    }
}

// Toggle movement on Z key press
function handleMovementToggle(event) {
    if (event.key === "z" || event.key === "Z") {
        movementActive = !movementActive;
        updateStatus('movement-status', movementActive);

        if (movementActive) {
            logActivity("Movement with Bombs activated");
            moveCharacter(); // Start movement loop
        } else {
            logActivity("Movement with Bombs deactivated");
            // Stop all movement and clear direction when disabled
            if (moveTimeout) {
                clearTimeout(moveTimeout);
                moveTimeout = null;
            }
            
            if (currentDirection) {
                simulateKeyUp(currentDirection);
                currentDirection = null;
                updateDirectionIndicator(null);
            }
        }
    }
}

// Helper functions for random movement
function getRandomDirection() {
    const directions = [ee.right, ee.down, ee.left, ee.up, ee.upLeft, ee.upRight, ee.downLeft, ee.downRight];
    return directions[Math.floor(Math.random() * directions.length)];
}

function getRandomDelay(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
}

function getRandomPause(min, max) {
    return Math.random() * (max - min) + min;
}

// Function to simulate placing a bomb (pressing "K")
function placeBomb() {
    if (!movementActive) return;
    
    var bombKeyEvent = new KeyboardEvent("keydown", { keyCode: 75, key: "k" });
    document.dispatchEvent(bombKeyEvent);
    activeKeys.add(75);
    updateActiveKeysDisplay();
    
    setTimeout(() => {
        var bombKeyReleaseEvent = new KeyboardEvent("keyup", { keyCode: 75, key: "k" });
        document.dispatchEvent(bombKeyReleaseEvent);
        activeKeys.delete(75);
        updateActiveKeysDisplay();
    }, 100);
    
    // Visual feedback - but only occasionally to reduce flickering
    if (Math.random() < 0.1) { // Only flash for 10% of bombs
        flashButtonStatus('movement-status');
    }
}

// Function to simulate random direction presses (W, A, S, D) for 50ms during pause
function randomDirectionPress() {
    if (!movementActive) return;
    
    const directions = [ee.up, ee.left, ee.down, ee.right];
    const direction = directions[Math.floor(Math.random() * directions.length)];
    
    // Simulate pressing a random direction key for 50ms
    simulateKeyDown(direction);
    setTimeout(() => {
        simulateKeyUp(direction); // Stop the key press after 50ms
    }, 50);
}

// Main movement function
function moveCharacter() {
    if (!movementActive) return;
    
    const direction = getRandomDirection();
    const delay = getRandomDelay(900, 1500); // Longer motion time
    const pauseTime = getRandomPause(125, 1000);
    
    // If there's an ongoing movement, stop it before starting a new one
    if (moveTimeout) {
        clearTimeout(moveTimeout); // Clear the previous movement timeout
    }
    
    // Always release all direction keys before changing direction to prevent stuck keys
    if (currentDirection) {
        simulateKeyUp(currentDirection);
    }
    
    // Place a bomb before changing direction
    placeBomb();
    
    // Start the new movement direction after bomb placement
    currentDirection = direction;
    
    // Update the direction indicator in UI
    updateDirectionIndicator(direction);
    
    setTimeout(() => {
        simulateKeyDown(direction);
        moveTimeout = setTimeout(() => {
            simulateKeyUp(direction); // Stop the current movement after delay
            currentDirection = null;
            
            // Simulate random direction press during the pause (50ms)
            randomDirectionPress();
            
            // Set timer for next movement
            moveTimeout = setTimeout(moveCharacter, pauseTime);
        }, delay);
    }, 100); // Wait 100ms for bomb placement before moving
}

// Initialize the addon when the core framework is ready
document.addEventListener('gamebot-initialized', initMovementAddon);
