// Base Script - Game Bot Framework
// Core functionality for the game bot with UI and key tracking

// Global variables for script control
let active = true; // General toggle state for the bot
let isToggling = false; // Flag to prevent duplicate toggling
let lastFlashTime = 0; // Track the last time a button was flashed
const FLASH_COOLDOWN = 300; // Minimum time between UI flashes in milliseconds
let minimized = false; // Track UI state
let activeKeys = new Set(); // Track currently pressed keys to prevent stuck keys

// Key mapping for easy reference 
const KEY_MAP = {
    87: "W",
    65: "A",
    83: "S",
    68: "D",
    75: "K",
    32: "Space",
    82: "R",
    37: "‚Üê",
    38: "‚Üë",
    39: "‚Üí",
    40: "‚Üì"
};

// Define key codes
const ee = {
    up: { keyCode: 87, key: "w" },
    left: { keyCode: 65, key: "a" },
    down: { keyCode: 83, key: "s" },
    right: { keyCode: 68, key: "d" },
    upLeft: { keys: [87, 65] },
    upRight: { keys: [87, 68] },
    downLeft: { keys: [83, 65] },
    downRight: { keys: [83, 68] }
};

// Create UI for visual feedback
function createVisualUI() {
    // Remove any existing UI first (prevents duplicates on re-initialization)
    const existingUI = document.getElementById('bot-ui-container');
    if (existingUI) {
        existingUI.remove();
    }

    // Create container for the UI
    const uiContainer = document.createElement('div');
    uiContainer.id = 'bot-ui-container';
    uiContainer.style.cssText = `
        position: fixed;
        top: 10px;
        right: 10px;
        width: 250px;
        background-color: rgba(0, 0, 0, 0.7);
        color: white;
        padding: 10px;
        border-radius: 8px;
        font-family: Arial, sans-serif;
        z-index: 9999;
        user-select: none;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
    `;

    // Create header
    const header = document.createElement('div');
    header.innerHTML = 'Game Bot Controls';
    header.style.cssText = `
        font-size: 16px;
        font-weight: bold;
        margin-bottom: 10px;
        text-align: center;
        padding-bottom: 5px;
        border-bottom: 1px solid #555;
    `;
    uiContainer.appendChild(header);

    // Add activity log
    const logContainer = document.createElement('div');
    logContainer.style.cssText = `
        margin-top: 10px;
        padding-top: 10px;
        border-top: 1px solid #555;
        max-height: 100px;
        overflow-y: auto;
    `;

    const logLabel = document.createElement('div');
    logLabel.textContent = 'Activity Log:';
    logLabel.style.marginBottom = '5px';
    logContainer.appendChild(logLabel);

    const logContent = document.createElement('div');
    logContent.id = 'bot-log';
    logContent.style.cssText = `
        font-size: 12px;
        color: #CCC;
    `;
    logContainer.appendChild(logContent);
    uiContainer.appendChild(logContainer);

    // Add emergency key release button
    const emergencyButton = document.createElement('button');
    emergencyButton.textContent = 'Release All Keys';
    emergencyButton.style.cssText = `
        background-color: #d9534f;
        color: white;
        border: none;
        border-radius: 4px;
        padding: 5px 10px;
        margin-top: 10px;
        cursor: pointer;
        width: 100%;
        font-weight: bold;
    `;
    emergencyButton.addEventListener('click', () => {
        releaseAllKeysEmergency();
        logActivity('Emergency key release triggered!');
    });
    uiContainer.appendChild(emergencyButton);

    // Add minimize/maximize button
    const toggleButton = document.createElement('button');
    toggleButton.textContent = '‚àí';
    toggleButton.style.cssText = `
        position: absolute;
        top: 5px;
        right: 5px;
        width: 20px;
        height: 20px;
        background: transparent;
        border: none;
        color: white;
        font-size: 16px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
    `;

    // Store references to content elements for minimize/maximize
    const contentElements = [
        logContainer,
        emergencyButton
    ];
    
    toggleButton.addEventListener('click', () => {
        minimized = !minimized;
        const elementsToToggle = document.querySelectorAll('#bot-ui-container > div:not(:first-child)');
        elementsToToggle.forEach(el => {
            el.style.display = minimized ? 'none' : 'block';
        });
        emergencyButton.style.display = minimized ? 'none' : 'block';
        toggleButton.textContent = minimized ? '+' : '‚àí';
    });
    
    uiContainer.appendChild(toggleButton);

    // Add the container to the document
    document.body.appendChild(uiContainer);
}

// Update UI status for a feature
function updateStatus(id, active, text = null) {
    const element = document.getElementById(id);
    if (element) {
        element.textContent = text || (active ? 'ON' : 'OFF');
        element.style.color = active ? '#4CAF50' : '#F44336';
    }
}

// Improved flash function with cooldown to reduce flickering
function flashButtonStatus(id, color = '#FFD700', duration = 100) {
    const now = Date.now();
    // Only flash if enough time has passed since the last flash
    if (now - lastFlashTime >= FLASH_COOLDOWN) {
        const element = document.getElementById(id);
        if (element) {
            const originalBackground = element.style.backgroundColor;
            element.style.backgroundColor = color;
            setTimeout(() => {
                element.style.backgroundColor = originalBackground;
            }, duration);
        }
        lastFlashTime = now;
    }
}

// Add message to the log
function logActivity(message) {
    const logElement = document.getElementById('bot-log');
    if (logElement) {
        const timestamp = new Date().toLocaleTimeString();
        const logItem = document.createElement('div');
        logItem.textContent = `[${timestamp}] ${message}`;
        logElement.prepend(logItem);
        
        // Limit number of log items
        if (logElement.children.length > 10) {
            logElement.removeChild(logElement.lastChild);
        }
    }
    console.log(message); // Still log to console as well
}

// Enhanced key simulation functions that track key state
function simulateKeyDown(direction) {
    if (typeof direction === 'number') {
        // Handle single keyCode input
        document.dispatchEvent(new KeyboardEvent("keydown", { keyCode: direction }));
        activeKeys.add(direction); // Add to active keys set
        return;
    }
    
    if (direction.keys) {
        direction.keys.forEach(keyCode => {
            document.dispatchEvent(new KeyboardEvent("keydown", { keyCode: keyCode }));
            activeKeys.add(keyCode); // Add to active keys set
        });
    } else {
        document.dispatchEvent(new KeyboardEvent("keydown", { keyCode: direction.keyCode, key: direction.key }));
        activeKeys.add(direction.keyCode); // Add to active keys set
    }
}

function simulateKeyUp(direction) {
    if (typeof direction === 'number') {
        // Handle single keyCode input
        document.dispatchEvent(new KeyboardEvent("keyup", { keyCode: direction }));
        activeKeys.delete(direction); // Remove from active keys
        return;
    }
    
    if (direction.keys) {
        direction.keys.forEach(keyCode => {
            document.dispatchEvent(new KeyboardEvent("keyup", { keyCode: keyCode }));
            activeKeys.delete(keyCode); // Remove from active keys
        });
    } else {
        document.dispatchEvent(new KeyboardEvent("keyup", { keyCode: direction.keyCode, key: direction.key }));
        activeKeys.delete(direction.keyCode); // Remove from active keys
    }
}

// Emergency function to release ALL keys (for stuck keys)
function releaseAllKeysEmergency() {
    // Release all common game keys
    [65, 68, 75, 82, 83, 87, 32, 37, 38, 39, 40].forEach(keyCode => {
        document.dispatchEvent(new KeyboardEvent("keyup", { keyCode: keyCode }));
    });
    
    // Also release any keys tracked in our activeKeys set
    activeKeys.forEach(keyCode => {
        document.dispatchEvent(new KeyboardEvent("keyup", { keyCode: keyCode }));
    });
    
    // Clear the active keys set
    activeKeys.clear();
    
    logActivity("All keys released - reset complete");
    
    // Call registered cleanup functions if any exist
    if (typeof window.gameBotCleanupFunctions === 'object') {
        window.gameBotCleanupFunctions.forEach(fn => {
            try {
                fn();
            } catch (e) {
                console.error("Error in cleanup function:", e);
            }
        });
    }
}

// Function to add feature display to the UI
function addFeatureToUI(id, label, initialActive) {
    const uiContainer = document.getElementById('bot-ui-container');
    if (!uiContainer) return false; // UI not initialized yet
    
    // Check if feature already exists
    if (document.getElementById(id)) return false;
    
    // Where to insert the new feature - right after the header
    const header = uiContainer.querySelector('div:first-child');
    
    // Create feature container
    const featureContainer = document.createElement('div');
    featureContainer.style.cssText = `
        display: flex;
        justify-content: space-between;
        margin-bottom: 8px;
        align-items: center;
    `;

    const featureLabel = document.createElement('span');
    featureLabel.textContent = label;

    const status = document.createElement('span');
    status.id = id;
    status.textContent = initialActive ? 'ON' : 'OFF';
    status.style.cssText = `
        font-weight: bold;
        color: ${initialActive ? '#4CAF50' : '#F44336'};
        background-color: rgba(0, 0, 0, 0.3);
        padding: 2px 6px;
        border-radius: 4px;
        transition: background-color 0.2s ease;
    `;

    featureContainer.appendChild(featureLabel);
    featureContainer.appendChild(status);
    
    // Insert after header
    if (header && header.nextSibling) {
        uiContainer.insertBefore(featureContainer, header.nextSibling);
    } else {
        uiContainer.appendChild(featureContainer);
    }
    
    return true;
}

// Initialize addon manager
window.gameBotAddonManager = {
    // Feature registry
    features: {},
    
    // Function to register a new feature/addon
    registerFeature: function(id, options) {
        if (this.features[id]) {
            console.warn(`Feature ${id} is already registered`);
            return false;
        }
        
        this.features[id] = {
            id: id,
            label: options.label || id,
            active: options.initialActive || false,
            initialize: options.initialize || function() {},
            cleanup: options.cleanup || function() {},
            onKeyDown: options.onKeyDown || function() {},
            onKeyUp: options.onKeyUp || function() {}
        };
        
        // Register cleanup function
        if (!window.gameBotCleanupFunctions) {
            window.gameBotCleanupFunctions = [];
        }
        window.gameBotCleanupFunctions.push(this.features[id].cleanup);
        
        // Initialize UI for the feature
        addFeatureToUI(id, this.features[id].label, this.features[id].active);
        
        // Initialize the feature
        this.features[id].initialize();
        
        console.log(`Feature ${id} registered successfully`);
        return true;
    }
};

// Add global document key event handlers
document.addEventListener("keydown", (event) => {
    // Call registered feature keydown handlers
    for (const id in window.gameBotAddonManager.features) {
        try {
            window.gameBotAddonManager.features[id].onKeyDown(event);
        } catch (e) {
            console.error(`Error in ${id} keydown handler:`, e);
        }
    }
});

document.addEventListener("keyup", (event) => {
    // Call registered feature keyup handlers
    for (const id in window.gameBotAddonManager.features) {
        try {
            window.gameBotAddonManager.features[id].onKeyUp(event);
        } catch (e) {
            console.error(`Error in ${id} keyup handler:`, e);
        }
    }
});

// Handle UI visibility restoration when window/tab becomes active again
document.addEventListener("visibilitychange", () => {
    if (!document.hidden && minimized) {
        // If the page was hidden and becomes visible again while UI is minimized
        const elementsToKeepHidden = document.querySelectorAll('#bot-ui-container > div:not(:first-child)');
        elementsToKeepHidden.forEach(el => {
            el.style.display = 'none';
        });
        
        // Also ensure the emergency button stays hidden
        const emergencyBtn = document.querySelector('#bot-ui-container > button:not(:last-child)');
        if (emergencyBtn) emergencyBtn.style.display = 'none';
    }
});

// Handle any cleanup needed when the window is closing
window.addEventListener('beforeunload', () => {
    // Make sure we clean up by releasing all keys
    releaseAllKeysEmergency();
});

// Function to fix/reload the bot UI and functionality
window.fixGameBot = function() {
    // Release all keys to fix any stuck keys
    releaseAllKeysEmergency();
    
    // Re-create the UI
    createVisualUI();
    
    // Re-initialize all registered features
    for (const id in window.gameBotAddonManager.features) {
        const feature = window.gameBotAddonManager.features[id];
        // Add the feature to the UI
        addFeatureToUI(id, feature.label, feature.active);
        // Reinitialize the feature
        try {
            feature.initialize();
        } catch (e) {
            console.error(`Error reinitializing ${id}:`, e);
        }
    }
    
    console.log("Game bot fixed and restarted!");
    return "Game bot UI and functionality restored.";
};

// Add periodic key state verification to prevent stuck keys
setInterval(() => {
    // If we have movement keys recorded as active for over 5 seconds,
    // something might be wrong - check and possibly release them
    if (activeKeys.size > 0) {
        logActivity("Periodic key check - ensuring no stuck keys");
    }
}, 5000); // Check every 5 seconds

// Initialize the script with UI
createVisualUI();
logActivity("Base Game Bot Framework initialized");

// K Hold Timer Addon with Russian UI
// This addon automatically holds the K key for exactly 3.875 seconds when toggled with H/–† key
(function() {
    // State variables for the K hold feature
    let holdActive = false;
    let holdTimeout = null;
    let progressInterval = null;
    const HOLD_DURATION = 3875; // Duration in milliseconds
    let timeRemaining = 0;
    let progressBarVisible = true; // Toggle for progress bar visibility
    let isToggling = false; // Flag to prevent duplicate toggling
    
    // Create progress bar UI with Russian text
    function createProgressUI() {
        const uiContainer = document.getElementById('bot-ui-container');
        if (!uiContainer) return;
        
        // Create progress panel
        const progressPanel = document.createElement('div');
        progressPanel.id = 'k-hold-progress-panel';
        progressPanel.style.cssText = `
            display: none;
            background-color: rgba(30, 30, 30, 0.95);
            padding: 10px;
            margin-top: 8px;
            border-radius: 4px;
            border: 1px solid #444;
        `;
        
        // Create progress bar container
        const progressContainer = document.createElement('div');
        progressContainer.style.cssText = `
            width: 100%;
            height: 20px;
            background-color: #333;
            border-radius: 4px;
            margin-bottom: 10px;
            overflow: hidden;
        `;
        
        // Create progress bar
        const progressBar = document.createElement('div');
        progressBar.id = 'k-hold-progress-bar';
        progressBar.style.cssText = `
            height: 100%;
            width: 0%;
            background-color: #4CAF50;
            transition: width 0.1s linear;
        `;
        
        progressContainer.appendChild(progressBar);
        
        // Create time display with Russian text
        const timeDisplay = document.createElement('div');
        timeDisplay.id = 'k-hold-time-display';
        timeDisplay.style.cssText = `
            text-align: center;
            font-family: monospace;
            margin-bottom: 10px;
        `;
        timeDisplay.textContent = '–ì–æ—Ç–æ–≤ - 3.875 —Å–µ–∫—É–Ω–¥';
        
        // Add toggle button for progress bar visibility with Russian text
        const toggleVisibilityButton = document.createElement('button');
        toggleVisibilityButton.textContent = '–°–∫—Ä—ã—Ç—å –ø—Ä–æ–≥—Ä–µ—Å—Å';
        toggleVisibilityButton.style.cssText = `
            background-color: #666;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 5px 10px;
            cursor: pointer;
            width: 100%;
            margin-bottom: 10px;
        `;
        
        toggleVisibilityButton.addEventListener('click', () => {
            progressBarVisible = !progressBarVisible;
            progressContainer.style.display = progressBarVisible ? 'block' : 'none';
            timeDisplay.style.display = progressBarVisible ? 'block' : 'none';
            toggleVisibilityButton.textContent = progressBarVisible ? '–°–∫—Ä—ã—Ç—å –ø—Ä–æ–≥—Ä–µ—Å—Å' : '–ü–æ–∫–∞–∑–∞—Ç—å –ø—Ä–æ–≥—Ä–µ—Å—Å';
        });
        
        // Add close button with Russian text
        const closeButton = document.createElement('button');
        closeButton.textContent = '–ó–∞–∫—Ä—ã—Ç—å';
        closeButton.style.cssText = `
            background-color: #666;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 5px 10px;
            cursor: pointer;
            width: 100%;
        `;
        
        closeButton.addEventListener('click', () => {
            progressPanel.style.display = 'none';
        });
        
        // Add all elements to the progress panel
        progressPanel.appendChild(progressContainer);
        progressPanel.appendChild(timeDisplay);
        progressPanel.appendChild(toggleVisibilityButton);
        progressPanel.appendChild(closeButton);
        
        // Add the progress panel to the UI container
        uiContainer.appendChild(progressPanel);
        
        // Add config button to main UI
        const holdConfigButton = document.createElement('button');
        holdConfigButton.textContent = 'üìä';
        holdConfigButton.style.cssText = `
            background: transparent;
            border: none;
            color: white;
            font-size: 14px;
            cursor: pointer;
            padding: 2px 6px;
            margin-left: 5px;
        `;
        
        holdConfigButton.addEventListener('click', () => {
            progressPanel.style.display = progressPanel.style.display === 'none' ? 'block' : 'none';
        });
        
        // Find the hold status element to place the config button next to it
        const holdStatusElement = document.getElementById('k-hold-status');
        if (holdStatusElement && holdStatusElement.parentNode) {
            holdStatusElement.parentNode.appendChild(holdConfigButton);
        }
    }
    
    // Start holding K key
    function startHolding() {
        // Clear existing timers if any
        stopHolding();
        
        // Simulate K keydown
        simulateKeyDown(75); // 75 is keyCode for 'K'
        logActivity("–£–¥–µ—Ä–∂–∏–≤–∞—é –∫–ª–∞–≤–∏—à—É K –Ω–∞ 3.875 —Å–µ–∫—É–Ω–¥");
        
        // Set time remaining
        timeRemaining = HOLD_DURATION;
        
        // Update progress bar
        updateProgressBar(100);
        
        // Set timer to release key after exact duration
        holdTimeout = setTimeout(() => {
            simulateKeyUp(75);
            logActivity("–ö–ª–∞–≤–∏—à–∞ K –æ—Ç–ø—É—â–µ–Ω–∞ –ø–æ—Å–ª–µ 3.875 —Å–µ–∫—É–Ω–¥");
            
            // Reset UI
            holdActive = false;
            updateStatus('k-hold-status', false);
            
            // Reset progress bar
            updateProgressBar(0);
            
            // Clear interval
            if (progressInterval) {
                clearInterval(progressInterval);
                progressInterval = null;
            }
            
            const timeDisplay = document.getElementById('k-hold-time-display');
            if (timeDisplay) {
                timeDisplay.textContent = '–ì–æ—Ç–æ–≤ - 3.875 —Å–µ–∫—É–Ω–¥';
            }
            
        }, HOLD_DURATION);
        
        // Start progress bar update interval
        progressInterval = setInterval(() => {
            // Decrease time remaining
            timeRemaining -= 100; // Update every 100ms
            
            // Calculate percentage of time remaining
            const percentRemaining = (timeRemaining / HOLD_DURATION) * 100;
            
            // Update progress bar
            updateProgressBar(percentRemaining);
            
            // Update time display with Russian text
            const timeDisplay = document.getElementById('k-hold-time-display');
            if (timeDisplay) {
                const secondsRemaining = (timeRemaining / 1000).toFixed(3);
                timeDisplay.textContent = `–û—Å—Ç–∞–ª–æ—Å—å: ${secondsRemaining}—Å`;
            }
            
            // Stop updating if time is up
            if (timeRemaining <= 0) {
                clearInterval(progressInterval);
                progressInterval = null;
            }
        }, 100); // Update every 100ms for smooth animation
    }
    
    // Stop holding K key
    function stopHolding() {
        // Clear timeout
        if (holdTimeout) {
            clearTimeout(holdTimeout);
            holdTimeout = null;
        }
        
        // Clear interval
        if (progressInterval) {
            clearInterval(progressInterval);
            progressInterval = null;
        }
        
        // Release K key
        simulateKeyUp(75);
        
        // Reset progress bar
        updateProgressBar(0);
        
        // Reset time display with Russian text
        const timeDisplay = document.getElementById('k-hold-time-display');
        if (timeDisplay) {
            timeDisplay.textContent = '–ì–æ—Ç–æ–≤ - 3.875 —Å–µ–∫—É–Ω–¥';
        }
    }
    
    // Update progress bar UI
    function updateProgressBar(percentage) {
        const progressBar = document.getElementById('k-hold-progress-bar');
        if (progressBar) {
            progressBar.style.width = `${percentage}%`;
            
            // Change color based on percentage
            if (percentage > 60) {
                progressBar.style.backgroundColor = '#4CAF50'; // Green
            } else if (percentage > 30) {
                progressBar.style.backgroundColor = '#FFC107'; // Yellow
            } else {
                progressBar.style.backgroundColor = '#F44336'; // Red
            }
        }
    }
    
    // Initialize function for the addon
    function initialize() {
        // Create the progress UI
        createProgressUI();
        
        // Start in deactivated state
        updateStatus('k-hold-status', holdActive);
        logActivity("–¢–∞–π–º–µ—Ä —É–¥–µ—Ä–∂–∞–Ω–∏—è K –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω (–ü–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ –∫–ª–∞–≤–∏—à–µ–π H/–†)");
    }
    
    // Cleanup function
    function cleanup() {
        stopHolding();
        holdActive = false;
        updateStatus('k-hold-status', false);
        logActivity("–¢–∞–π–º–µ—Ä —É–¥–µ—Ä–∂–∞–Ω–∏—è K –æ—Ç–∫–ª—é—á–µ–Ω");
        
        // Remove progress panel if it exists
        const progressPanel = document.getElementById('k-hold-progress-panel');
        if (progressPanel) {
            progressPanel.remove();
        }
    }
    
    // Toggle hold mode
    function toggleHoldMode() {
        if (!isToggling) {
            isToggling = true;
            
            holdActive = !holdActive;
            updateStatus('k-hold-status', holdActive);
            
            if (holdActive) {
                startHolding();
            } else {
                stopHolding();
                logActivity("–¢–∞–π–º–µ—Ä —É–¥–µ—Ä–∂–∞–Ω–∏—è K –¥–µ–∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω");
            }
            
            setTimeout(() => {
                isToggling = false;
            }, 100);
        }
    }
    
    // Handle keydown events - support both Latin 'H' and Cyrillic '–†' (Russian equivalent)
    function onKeyDown(event) {
        // Check for both Latin 'h' and Cyrillic '—Ä' (Russian H key equivalent)
        if (event.key.toLowerCase() === 'h' || event.key === '—Ä' || event.key === '–†') {
            toggleHoldMode();
        }
    }
    
    // Register the feature with the addon manager
    window.gameBotAddonManager.registerFeature('k-hold-status', {
        label: '–ó–∞–¥–µ—Ä–∂–∫–∞ –ë–æ–º–± (H/–†)',
        initialActive: holdActive,
        initialize: initialize,
        cleanup: cleanup,
        onKeyDown: onKeyDown
    });
})();

// Random Movement with Bombs Addon - English (WASD) & Russian (–¶–§–´–í) Layout Support
// This addon makes the character move in random directions and place bombs

// Global variables for random movement
let rm_firstScriptActive = false;
let rm_moveTimeout = null;
let rm_currentDirection = null;

// Define key codes for both English and Russian layouts
const rm_ee = {
    // English WASD
    up: { keyCode: 87, key: "w" },            // W
    left: { keyCode: 65, key: "a" },          // A
    down: { keyCode: 83, key: "s" },          // S
    right: { keyCode: 68, key: "d" },         // D
    
    // Russian –¶–§–´–í (same physical keys on keyboard)
    upRu: { keyCode: 87, key: "—Ü" },          // –¶ (W key position)
    leftRu: { keyCode: 65, key: "—Ñ" },        // –§ (A key position)
    downRu: { keyCode: 83, key: "—ã" },        // –´ (S key position)
    rightRu: { keyCode: 68, key: "–≤" },       // –í (D key position)
    
    // Diagonals - English
    upLeft: { keys: [87, 65] },               // W+A
    upRight: { keys: [87, 68] },              // W+D
    downLeft: { keys: [83, 65] },             // S+A
    downRight: { keys: [83, 68] },            // S+D
    
    // Diagonals - Russian (same keyCodes, different key values)
    upLeftRu: { keys: [87, 65] },             // –¶+–§
    upRightRu: { keys: [87, 68] },            // –¶+–í
    downLeftRu: { keys: [83, 65] },           // –´+–§
    downRightRu: { keys: [83, 68] }           // –´+–í
};

// Create UI for this functionality
function rm_createUI() {
    // Check if main UI container exists
    const botUiContainer = document.getElementById('bot-ui-container');
    if (!botUiContainer) {
        console.log("Main bot UI not found. Random Movement will retry in 1 second.");
        setTimeout(rm_createUI, 1000);
        return;
    }
    
    // Remove any existing controls to prevent duplicates
    const existingControl = document.getElementById('movement-status');
    if (existingControl && existingControl.parentElement) {
        existingControl.parentElement.remove();
    }
    
    // Create movement container
    const movementContainer = document.createElement('div');
    movementContainer.style.cssText = `
        display: flex;
        justify-content: space-between;
        margin-bottom: 8px;
        align-items: center;
    `;
    
    const movementLabel = document.createElement('span');
    movementLabel.textContent = '–ë–æ—Ç —Å –ë–æ–º–±–∞–º–∏ (Z/–Ø)';
    
    const movementStatus = document.createElement('span');
    movementStatus.id = 'movement-status';
    movementStatus.textContent = rm_firstScriptActive ? 'ON' : 'OFF';
    movementStatus.style.cssText = `
        font-weight: bold;
        color: ${rm_firstScriptActive ? '#4CAF50' : '#F44336'};
        background-color: rgba(0, 0, 0, 0.3);
        padding: 2px 6px;
        border-radius: 4px;
        transition: background-color 0.2s ease;
    `;
    
    movementContainer.appendChild(movementLabel);
    movementContainer.appendChild(movementStatus);
    
    // Insert at the top of the UI (right after the header)
    const header = botUiContainer.querySelector('div:first-child');
    if (header && header.nextSibling) {
        botUiContainer.insertBefore(movementContainer, header.nextSibling);
    } else {
        // Fallback: append to the main container
        botUiContainer.appendChild(movementContainer);
    }
    
    // Log the addition
    if (typeof logActivity === 'function') {
        logActivity("Random Movement UI added (EN/RU support)");
    } else {
        console.log("Random Movement UI added (EN/RU support)");
    }
}

// Update movement status display
function rm_updateStatus() {
    const movementStatus = document.getElementById('movement-status');
    if (movementStatus) {
        movementStatus.textContent = rm_firstScriptActive ? 'ON' : 'OFF';
        movementStatus.style.color = rm_firstScriptActive ? '#4CAF50' : '#F44336';
    }
}

// Flash effect for visual feedback
function rm_flashStatus(color = '#FFD700', duration = 100) {
    const element = document.getElementById('movement-status');
    if (element) {
        const originalBackground = element.style.backgroundColor;
        element.style.backgroundColor = color;
        setTimeout(() => {
            element.style.backgroundColor = originalBackground;
        }, duration);
    }
}

// Function to simulate key press down, with integration to main script if available
function rm_simulateKeyDown(direction) {
    if (typeof direction === 'number') {
        // Handle single key code
        document.dispatchEvent(new KeyboardEvent("keydown", { keyCode: direction }));
        
        // Integrate with main script's active keys tracking if available
        if (typeof window.activeKeys !== 'undefined') {
            window.activeKeys.add(direction);
            if (typeof window.updateActiveKeysDisplay === 'function') {
                window.updateActiveKeysDisplay();
            }
        }
        return;
    }
    
    if (direction.keys) {
        // Handle multiple keys
        direction.keys.forEach(keyCode => {
            document.dispatchEvent(new KeyboardEvent("keydown", { keyCode: keyCode }));
            
            // Integrate with main script's active keys tracking if available
            if (typeof window.activeKeys !== 'undefined') {
                window.activeKeys.add(keyCode);
            }
        });
    } else {
        // Handle single key in direction object
        document.dispatchEvent(new KeyboardEvent("keydown", { 
            keyCode: direction.keyCode,
            key: direction.key 
        }));
        
        // Integrate with main script's active keys tracking if available
        if (typeof window.activeKeys !== 'undefined') {
            window.activeKeys.add(direction.keyCode);
        }
    }
    
    // Update display if available
    if (typeof window.updateActiveKeysDisplay === 'function') {
        window.updateActiveKeysDisplay();
    }
    
    // Update direction indicator if available
    if (typeof window.updateDirectionIndicator === 'function') {
        window.updateDirectionIndicator(direction);
    }
}

// Function to simulate key release, with integration to main script if available
function rm_simulateKeyUp(direction) {
    if (typeof direction === 'number') {
        // Handle single key code
        document.dispatchEvent(new KeyboardEvent("keyup", { keyCode: direction }));
        
        // Integrate with main script's active keys tracking if available
        if (typeof window.activeKeys !== 'undefined') {
            window.activeKeys.delete(direction);
            if (typeof window.updateActiveKeysDisplay === 'function') {
                window.updateActiveKeysDisplay();
            }
        }
        return;
    }
    
    if (direction.keys) {
        // Handle multiple keys
        direction.keys.forEach(keyCode => {
            document.dispatchEvent(new KeyboardEvent("keyup", { keyCode: keyCode }));
            
            // Integrate with main script's active keys tracking if available
            if (typeof window.activeKeys !== 'undefined') {
                window.activeKeys.delete(keyCode);
            }
        });
    } else {
        // Handle single key in direction object
        document.dispatchEvent(new KeyboardEvent("keyup", { 
            keyCode: direction.keyCode,
            key: direction.key 
        }));
        
        // Integrate with main script's active keys tracking if available
        if (typeof window.activeKeys !== 'undefined') {
            window.activeKeys.delete(direction.keyCode);
        }
    }
    
    // Update display if available
    if (typeof window.updateActiveKeysDisplay === 'function') {
        window.updateActiveKeysDisplay();
    }
    
    // Update direction indicator if available
    if (typeof window.updateDirectionIndicator === 'function') {
        window.updateDirectionIndicator(null);
    }
}

// Get random direction
function rm_getRandomDirection() {
    const directions = [
        rm_ee.right, rm_ee.down, rm_ee.left, rm_ee.up, 
        rm_ee.upLeft, rm_ee.upRight, rm_ee.downLeft, rm_ee.downRight
    ];
    return directions[Math.floor(Math.random() * directions.length)];
}

// Get random delay
function rm_getRandomDelay(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
}

// Get random pause
function rm_getRandomPause(min, max) {
    return Math.random() * (max - min) + min;
}

// Function to place a bomb (press 'K' or '–õ')
function rm_placeBomb() {
    if (!rm_firstScriptActive) return;
    
    // For both English and Russian layouts, K key has the same keyCode
    var bombKeyEvent = new KeyboardEvent("keydown", { keyCode: 75 });
    document.dispatchEvent(bombKeyEvent);
    
    // Update activeKeys if available
    if (typeof window.activeKeys !== 'undefined') {
        window.activeKeys.add(75);
        if (typeof window.updateActiveKeysDisplay === 'function') {
            window.updateActiveKeysDisplay();
        }
    }
    
    // Release K after short delay
    setTimeout(() => {
        var bombKeyReleaseEvent = new KeyboardEvent("keyup", { keyCode: 75 });
        document.dispatchEvent(bombKeyReleaseEvent);
        
        // Update activeKeys if available
        if (typeof window.activeKeys !== 'undefined') {
            window.activeKeys.delete(75);
            if (typeof window.updateActiveKeysDisplay === 'function') {
                window.updateActiveKeysDisplay();
            }
        }
    }, 100);
    
    // Visual feedback - occasionally to reduce flickering
    if (Math.random() < 0.1) { // 10% chance to flash
        rm_flashStatus('#FFD700');
    }
}

// Function to simulate random direction presses during pauses
function rm_randomDirectionPress() {
    if (!rm_firstScriptActive) return;
    
    const directions = [rm_ee.up, rm_ee.left, rm_ee.down, rm_ee.right];
    const direction = directions[Math.floor(Math.random() * directions.length)];
    
    // Press random direction key for 50ms
    rm_simulateKeyDown(direction);
    setTimeout(() => {
        rm_simulateKeyUp(direction);
    }, 50);
}

// Main function to move character in random directions
function rm_moveCharacter() {
    if (!rm_firstScriptActive) return;
    
    const direction = rm_getRandomDirection();
    const delay = rm_getRandomDelay(900, 1500); // Movement duration
    const pauseTime = rm_getRandomPause(125, 1000); // Pause duration
    
    // Clear any existing movement timeout
    if (rm_moveTimeout) {
        clearTimeout(rm_moveTimeout);
    }
    
    // Release any current direction keys
    if (rm_currentDirection) {
        rm_simulateKeyUp(rm_currentDirection);
    }
    
    // Place bomb before moving
    rm_placeBomb();
    
    // Set the new direction
    rm_currentDirection = direction;
    
    // Start moving after short delay for bomb placement
    setTimeout(() => {
        rm_simulateKeyDown(direction);
        
        rm_moveTimeout = setTimeout(() => {
            rm_simulateKeyUp(direction); // Stop current movement
            rm_currentDirection = null;
            
            // Random direction press during pause
            rm_randomDirectionPress();
            
            // Schedule next movement
            rm_moveTimeout = setTimeout(rm_moveCharacter, pauseTime);
        }, delay);
    }, 100);
}

// Detect keyboard layout - This is just an approximation, as there's no perfect way to detect layout
let rm_isRussianLayout = false;

// Function to check if the keyboard layout is Russian
function rm_checkKeyboardLayout() {
    // A simple way to check is to create a hidden input, focus it, and check some keyboard events
    const testInput = document.createElement('input');
    testInput.style.position = 'absolute';
    testInput.style.opacity = '0';
    testInput.style.pointerEvents = 'none';
    document.body.appendChild(testInput);
    
    // Try to detect based on system locale
    const lang = navigator.language || navigator.userLanguage;
    if (lang && lang.toLowerCase().startsWith('ru')) {
        rm_isRussianLayout = true;
    }
    
    // Cleanup
    document.body.removeChild(testInput);
    
    if (typeof logActivity === 'function') {
        logActivity(`Keyboard layout detected: ${rm_isRussianLayout ? 'Russian' : 'English/Other'}`);
    } else {
        console.log(`Keyboard layout detected: ${rm_isRussianLayout ? 'Russian' : 'English/Other'}`);
    }
}

// Try to detect keyboard layout on init
rm_checkKeyboardLayout();

// Toggle random movement with both Z key (English) and –Ø key (Russian)
document.addEventListener("keydown", (event) => {
    // Z key in English layout or –Ø key in Russian layout (both same physical key)
    if (event.key === "z" || event.key === "Z" || event.key === "—è" || event.key === "–Ø") {
        rm_firstScriptActive = !rm_firstScriptActive;
        rm_updateStatus();
        
        if (rm_firstScriptActive) {
            if (typeof logActivity === 'function') {
                logActivity("Random movement with bombs enabled");
            } else {
                console.log("Random movement with bombs enabled");
            }
            rm_moveCharacter(); // Start movement
        } else {
            if (typeof logActivity === 'function') {
                logActivity("Random movement with bombs disabled");
            } else {
                console.log("Random movement with bombs disabled");
            }
            
            // Stop all movement
            if (rm_moveTimeout) {
                clearTimeout(rm_moveTimeout);
                rm_moveTimeout = null;
            }
            
            // Release current direction keys
            if (rm_currentDirection) {
                rm_simulateKeyUp(rm_currentDirection);
                rm_currentDirection = null;
                
                // Update direction indicator if available
                if (typeof window.updateDirectionIndicator === 'function') {
                    window.updateDirectionIndicator(null);
                }
            }
        }
    }
});

// Clean up on page unload
window.addEventListener('beforeunload', () => {
    if (rm_moveTimeout) {
        clearTimeout(rm_moveTimeout);
    }
    
    if (rm_currentDirection) {
        rm_simulateKeyUp(rm_currentDirection);
    }
});

// Initialize
rm_createUI();

// Extend the fixGameBot function if it exists
if (typeof window.fixGameBot !== 'undefined') {
    const originalFixGameBot = window.fixGameBot;
    window.fixGameBot = function() {
        // Call the original function
        const result = originalFixGameBot();
        
        // Re-add our UI
        rm_createUI();
        
        // Restart movement if active
        if (rm_firstScriptActive) {
            // First clear any existing movement
            if (rm_moveTimeout) {
                clearTimeout(rm_moveTimeout);
            }
            if (rm_currentDirection) {
                rm_simulateKeyUp(rm_currentDirection);
                rm_currentDirection = null;
            }
            
            // Then restart
            rm_moveCharacter();
        }
        
        return result + " Random Movement restored.";
    };
} else {
    // Create a new fixGameBot function if it doesn't exist
    window.fixGameBot = function() {
        rm_createUI();
        return "Random Movement restored.";
    };
}
// Auto-Respawn Addon for Game Bot Framework
// This addon adds auto-respawn functionality to the base bot framework
// Now supporting both English and Russian keyboard layouts

// Create module-level variables outside the addon object to solve 'this' context issues
let autoRespawn_active = false;
let autoRespawn_checkInterval = null;
let autoRespawn_respawnTimer = null;
let autoRespawn_movementTimer = null;

// Function to check for respawn button and handle respawning
function autoRespawn_checkForRespawn() {
    const scoreboard = document.getElementById("scoreboard-new");
    
    // Skip if scoreboard is not visible
    if (scoreboard && scoreboard.offsetParent === null) {
        return;
    }
    
    // Find respawn button if it exists
    const respawnButton = [...document.getElementsByTagName("button")]
        .filter(b => b.innerText.indexOf("Respawn [Space]") === 0)[0];
    
    if (respawnButton) {
        // Clear any existing timers
        if (autoRespawn_respawnTimer) clearTimeout(autoRespawn_respawnTimer);
        if (autoRespawn_movementTimer) clearTimeout(autoRespawn_movementTimer);
        
        // Click the respawn button
        respawnButton.click();
        logActivity("Auto-respawn clicked respawn button");
        
        // Set timer for movement sequence
        autoRespawn_respawnTimer = setTimeout(() => {
            logActivity("Executing post-respawn movement sequence");
            
            // Simulate left keypress
            simulateKeyDown(37); // Left arrow
            
            // Release left key after 50ms
            setTimeout(() => {
                simulateKeyUp(37); // Left arrow
                
                // Simulate right keypress after left completes
                setTimeout(() => {
                    simulateKeyDown(39); // Right arrow
                    
                    // Release right key after 50ms
                    setTimeout(() => {
                        simulateKeyUp(39); // Right arrow
                    }, 50);
                }, 50);
            }, 50);
        }, 3000); // 3 seconds after respawn
    }
}

// Function to start the auto-respawn check interval
function autoRespawn_startChecking() {
    // Stop any existing interval first
    autoRespawn_stopChecking();
    
    // Start new interval
    autoRespawn_checkInterval = setInterval(() => {
        if (autoRespawn_active) {
            autoRespawn_checkForRespawn();
        }
    }, 100);
    
    logActivity("Auto-respawn checker started");
}

// Function to stop the auto-respawn check interval
function autoRespawn_stopChecking() {
    if (autoRespawn_checkInterval) {
        clearInterval(autoRespawn_checkInterval);
        autoRespawn_checkInterval = null;
    }
    
    // Clear any pending timers
    if (autoRespawn_respawnTimer) {
        clearTimeout(autoRespawn_respawnTimer);
        autoRespawn_respawnTimer = null;
    }
    
    if (autoRespawn_movementTimer) {
        clearTimeout(autoRespawn_movementTimer);
        autoRespawn_movementTimer = null;
    }
}

// Register the auto-respawn addon with the bot framework
window.gameBotAddonManager.registerFeature('autoRespawnAddon', {
    label: '–î–≤–∏–∂–µ–Ω–∏–µ(V/–ú)',
    initialActive: false, // Start inactive by default
    
    // Initialize the addon
    initialize: function() {
        // Add visualization for auto-respawn state in the main UI
        logActivity("Auto-respawn addon initialized - use 'V' (English) or '–ú' (Russian) key to toggle");
        
        // Set the initial active state
        autoRespawn_active = this.active;
        
        // Start checking for respawn if initially active
        if (autoRespawn_active) {
            autoRespawn_startChecking();
        }
        
        // Initial UI status update
        updateStatus('autoRespawnAddon', this.active);
    },
    
    // Cleanup when the addon is disabled
    cleanup: function() {
        // Stop any ongoing checks
        autoRespawn_stopChecking();
        
        logActivity("Auto-respawn addon cleanup complete");
    },
    
    // Handle keydown events
    onKeyDown: function(event) {
        const key = event.key.toLowerCase();
        // Toggle auto-respawn mode with V key (English) or –º key (Russian)
        if (key === 'v' || key === '–º') {
            this.active = !this.active;
            autoRespawn_active = this.active;
            updateStatus('autoRespawnAddon', this.active);
            
            // Start or stop auto-respawn based on active state
            if (autoRespawn_active) {
                autoRespawn_startChecking();
                logActivity("Auto-respawn activated");
            } else {
                autoRespawn_stopChecking();
                logActivity("Auto-respawn deactivated");
            }
        }
    },
    
    // Placeholder for onKeyUp - not used in this addon but required by framework
    onKeyUp: function(event) {
        // No special handling needed for keyup events
    }
});

// Log that the addon was loaded
logActivity("Auto-respawn addon loaded - Press 'V' (English) or '–ú' (Russian) to toggle auto-respawn mode");

// Rotation Addon for Game Bot Framework
// This addon adds rotation functionality to the base bot framework with support for both QWERTY and Russian keyboard layouts
// Create module-level variables outside the addon object to solve 'this' context issues
let rotationAddon_inProgress = false;
let rotationAddon_interval = null;
let rotationAddon_active = false;

// Key mapping for both layouts
const KEY_MAPPINGS = {
    // QWERTY layout
    'w': 38, // Up arrow
    'a': 37, // Left arrow
    's': 40, // Down arrow
    'd': 39, // Right arrow
    
    // Russian layout equivalents (Cyrillic letters at same positions as WASD)
    '—Ü': 38, // Up arrow (Russian 'ts' - position of 'w')
    '—Ñ': 37, // Left arrow (Russian 'f' - position of 'a')
    '—ã': 40, // Down arrow (Russian 'y' - position of 's')
    '–≤': 39  // Right arrow (Russian 'v' - position of 'd')
};

function rotationAddon_performRotation() {
    if (!rotationAddon_active) return;
    
    // Only start if not already in progress
    if (rotationAddon_inProgress) return;
    
    rotationAddon_inProgress = true;
    
    let currentStep = 0;
    // W(up), A(left), S(down), D(right), S(down), A(left) translated to arrow key codes
    const sequenceKeys = [38, 37, 40, 39, 40, 37];
    
    rotationAddon_interval = setInterval(() => {
        // Use the framework's key simulation functions
        simulateKeyDown(sequenceKeys[currentStep]);
        
        setTimeout(() => {
            simulateKeyUp(sequenceKeys[currentStep]);
            currentStep = (currentStep + 1) % 6; // Cycle through all 6 steps
        }, 5);
    }, 100);
}

function rotationAddon_stopRotation() {
    if (rotationAddon_interval) {
        clearInterval(rotationAddon_interval);
        rotationAddon_interval = null;
    }
    
    rotationAddon_inProgress = false;
    
    // Release all arrow keys if they're being held
    [37, 38, 39, 40].forEach(keyCode => {
        simulateKeyUp(keyCode);
    });
}

// Register the rotation addon with the bot framework
window.gameBotAddonManager.registerFeature('rotationAddon', {
    label: '–†–µ–∂–∏–º –í—Ä–∞—â–µ–Ω–∏—è(N/–¢)',
    initialActive: false,
    
    // Initialize the addon
    initialize: function() {
        // Add visualization for rotation state in the main UI
        logActivity("Rotation addon initialized - use 'N' or '–¢' key to toggle");
        
        // Set the initial active state
        rotationAddon_active = this.active;
        
        // Initial UI status update
        updateStatus('rotationAddon', this.active);
    },
    
    // Cleanup when the addon is disabled
    cleanup: function() {
        // Clear any ongoing rotation
        rotationAddon_stopRotation();
        
        logActivity("Rotation addon cleanup complete");
    },
    
    // Handle keydown events
    onKeyDown: function(event) {
        const key = event.key.toLowerCase();
        
        // Toggle rotation mode with N key (or Russian equivalent '—Ç')
        if (key === 'n' || key === '—Ç') {
            this.active = !this.active;
            rotationAddon_active = this.active;
            updateStatus('rotationAddon', this.active);
            
            // Start or stop rotation based on active state
            if (rotationAddon_active) {
                rotationAddon_performRotation();
                logActivity("Rotation mode activated - continuous rotation until toggled off");
            } else {
                rotationAddon_stopRotation();
                logActivity("Rotation mode deactivated");
            }
        }
        
        // Handle manual movement with WASD or Russian equivalents
        // This allows users to control movement manually with either keyboard layout
        if (!rotationAddon_active && KEY_MAPPINGS[key]) {
            simulateKeyDown(KEY_MAPPINGS[key]);
        }
    },
    
    // Handle keyup events for manual movement keys
    onKeyUp: function(event) {
        const key = event.key.toLowerCase();
        
        // Release the corresponding arrow key when WASD or Russian equivalent is released
        if (KEY_MAPPINGS[key]) {
            simulateKeyUp(KEY_MAPPINGS[key]);
        }
    }
});

// Log that the addon was loaded
logActivity("Rotation addon loaded - Press 'N' (English) or '–¢' (Russian) to toggle continuous rotation mode");
// Cross Movement Addon for Game Bot Framework
// This addon adds modified movement pattern functionality to the base bot framework
// Pattern: up-down twice, then left-right twice
// Supports both English and Russian keyboard layouts

// Create module-level variables outside the addon object to solve 'this' context issues
let crossMovement_isRunning = false;
let crossMovement_loopTimer = null;
let crossMovement_enabled = false;

// Keyboard mapping for both layouts
const keyMappings = {
    // English WASD keys to arrow key codes
    'w': 38, // Up
    's': 40, // Down
    'a': 37, // Left
    'd': 39, // Right
    
    // Russian layout equivalents (Cyrillic)
    '—Ü': 38, // Up (Russian '—Ü' is in same position as 'w')
    '—ã': 40, // Down (Russian '—ã' is in same position as 's')
    '—Ñ': 37, // Left (Russian '—Ñ' is in same position as 'a')
    '–≤': 39, // Right (Russian '–≤' is in same position as 'd')
    
    // Direct arrow key codes (work in both layouts)
    'arrowup': 38,
    'arrowdown': 40,
    'arrowleft': 37,
    'arrowright': 39,
    
    // Toggle key (both layouts)
    'm': 'toggle',
    '—å': 'toggle' // Russian '—å' is in same position as 'm'
};

// Helper functions at module level
function crossMovement_startMovementPattern() {
    if (!crossMovement_enabled) return;
    
    // Only start if not already in progress
    if (crossMovement_isRunning) return;
    
    crossMovement_isRunning = true;
    
    let stepIndex = 0;
    // Modified sequence: Up-Down-Up-Down-Left-Right-Left-Right
    const movementSequence = [
        38, 40,  // Up, Down (first time)
        38, 40,  // Up, Down (second time)
        37, 39,  // Left, Right (first time)
        37, 39   // Left, Right (second time)
    ];
    
    crossMovement_loopTimer = setInterval(() => {
        // Use the framework's key simulation functions
        simulateKeyDown(movementSequence[stepIndex]);
        
        setTimeout(() => {
            simulateKeyUp(movementSequence[stepIndex]);
            stepIndex = (stepIndex + 1) % 8; // Cycle through all 8 steps
        }, 5);
    }, 200);
}

function crossMovement_stopMovementPattern() {
    if (crossMovement_loopTimer) {
        clearInterval(crossMovement_loopTimer);
        crossMovement_loopTimer = null;
    }
    
    crossMovement_isRunning = false;
    
    // Release all arrow keys if they're being held
    [37, 38, 39, 40].forEach(keyCode => {
        simulateKeyUp(keyCode);
    });
}

// Register the cross movement addon with the bot framework
window.gameBotAddonManager.registerFeature('crossMovementAddon', {
    label: '–î–≤–∏–≥ –ö—Ä–µ—Å—Ç–æ–º(M/–¨)',  // Updated label to show both English and Russian toggle keys
    initialActive: false,
    
    // Initialize the addon
    initialize: function() {
        logActivity("Modified cross movement addon initialized - use 'M' key (English) or '–¨' key (Russian) to toggle");
        
        // Set the initial active state
        crossMovement_enabled = this.active;
        
        // Initial UI status update in framework
        updateStatus('crossMovementAddon', this.active);
    },
    
    // Cleanup when the addon is disabled
    cleanup: function() {
        // Clear any ongoing movement pattern
        crossMovement_stopMovementPattern();
        
        logActivity("Modified cross movement addon cleanup complete");
    },
    
    // Handle keydown events
    onKeyDown: function(event) {
        const key = event.key.toLowerCase();
        const mappedKey = keyMappings[key];
        
        // Toggle cross movement mode with M key (or Russian equivalent)
        if (mappedKey === 'toggle') {
            this.active = !this.active;
            crossMovement_enabled = this.active;
            updateStatus('crossMovementAddon', this.active);
            
            // Start or stop movement pattern based on active state
            if (crossMovement_enabled) {
                crossMovement_startMovementPattern();
                logActivity("Modified movement mode activated - up-down twice, left-right twice pattern");
            } else {
                crossMovement_stopMovementPattern();
                logActivity("Modified movement mode deactivated");
            }
        }
    },
    
    // Placeholder for onKeyUp - not used in this addon but required by framework
    onKeyUp: function(event) {
        // No special handling needed for keyup events
    }
});

// Log that the addon was loaded
logActivity("Modified cross movement addon loaded - Press 'M' (English) or '–¨' (Russian) to toggle up-down twice, left-right twice pattern");
// Auto Respawn Addon
// This addon automatically clicks the respawn button and can optionally press R key after respawning
// Supports both Latin and Cyrillic keyboard layouts

// Global variables for the auto respawn functionality
let ar_secondScriptActive = false; // Auto-respawn disabled by default
let ar_pressRAfterRespawn = false; // R key press after respawn disabled by default
let ar_scoreBoardInterval = null;
let ar_respawnTimer = null;

// Create UI elements for auto respawn
function ar_createUI() {
    // Check if main UI container exists
    const botUiContainer = document.getElementById('bot-ui-container');
    if (!botUiContainer) {
        console.log("Main bot UI not found. Auto Respawn will retry in 1 second.");
        setTimeout(ar_createUI, 1000);
        return;
    }
    
    // Remove any existing auto respawn controls to prevent duplicates
    const existingControl = document.getElementById('respawn-status');
    if (existingControl && existingControl.parentElement) {
        existingControl.parentElement.remove();
    }
    
    // Create auto respawn container
    const respawnContainer = document.createElement('div');
    respawnContainer.style.cssText = `
        display: flex;
        justify-content: space-between;
        margin-bottom: 8px;
        align-items: center;
    `;
    
    const respawnLabel = document.createElement('span');
    respawnLabel.textContent = '–†–µ—Å–ø–∞–≤–Ω (–ß/X) (–¢—ã–∫–≤–∞ (T/–ï) ' + (ar_pressRAfterRespawn ? '–î' : '–ù') + ')';
    respawnLabel.id = 'respawn-label';
    
    const respawnStatus = document.createElement('span');
    respawnStatus.id = 'respawn-status';
    respawnStatus.textContent = ar_secondScriptActive ? 'ON' : 'OFF';
    respawnStatus.style.cssText = `
        font-weight: bold;
        color: ${ar_secondScriptActive ? '#4CAF50' : '#F44336'};
        background-color: rgba(0, 0, 0, 0.3);
        padding: 2px 6px;
        border-radius: 4px;
    `;
    
    respawnContainer.appendChild(respawnLabel);
    respawnContainer.appendChild(respawnStatus);
    
    // Find where to insert our control - try to insert after the first control
    const firstControl = botUiContainer.querySelector('div > div:not(:first-child)');
    if (firstControl) {
        firstControl.insertAdjacentElement('afterend', respawnContainer);
    } else {
        // Fallback: append to the main container
        botUiContainer.appendChild(respawnContainer);
    }
    
    // Log the addition via the main script's logActivity if available
    if (typeof logActivity === 'function') {
        logActivity("Auto Respawn UI added");
    } else {
        console.log("Auto Respawn UI added");
    }
}

// Update auto respawn status
function ar_updateStatus() {
    const respawnStatus = document.getElementById('respawn-status');
    if (respawnStatus) {
        respawnStatus.textContent = ar_secondScriptActive ? 'ON' : 'OFF';
        respawnStatus.style.color = ar_secondScriptActive ? '#4CAF50' : '#F44336';
    }
    
    // Update the label to show R key press status
    const respawnLabel = document.getElementById('respawn-label');
    if (respawnLabel) {
        respawnLabel.textContent = '–†–µ—Å–ø–∞–≤–Ω(–ß/X) T—ã–∫–≤–∞(–¢/–ï) ' + (ar_pressRAfterRespawn ? '–î' : '–ù') + ')';
    }
}

// Flash effect for visual feedback
function ar_flashStatus(color = '#FFD700', duration = 300) {
    const element = document.getElementById('respawn-status');
    if (element) {
        const originalBackground = element.style.backgroundColor;
        element.style.backgroundColor = color;
        setTimeout(() => {
            element.style.backgroundColor = originalBackground;
        }, duration);
    }
}

// Function to simulate key press down
function ar_simulateKeyDown(keyCode) {
    document.dispatchEvent(new KeyboardEvent("keydown", { keyCode: keyCode }));
    
    // If the main script has activeKeys tracking, use it
    if (typeof window.activeKeys !== 'undefined') {
        window.activeKeys.add(keyCode);
        if (typeof window.updateActiveKeysDisplay === 'function') {
            window.updateActiveKeysDisplay();
        }
    }
}

// Function to simulate key release
function ar_simulateKeyUp(keyCode) {
    document.dispatchEvent(new KeyboardEvent("keyup", { keyCode: keyCode }));
    
    // If the main script has activeKeys tracking, use it
    if (typeof window.activeKeys !== 'undefined') {
        window.activeKeys.delete(keyCode);
        if (typeof window.updateActiveKeysDisplay === 'function') {
            window.updateActiveKeysDisplay();
        }
    }
}

// Release all keys (emergency function)
function ar_releaseAllKeys() {
    // Common game keys
    [65, 68, 75, 82, 83, 87, 32].forEach(keyCode => {
        ar_simulateKeyUp(keyCode);
    });
    
    // If main script has releaseAllKeysEmergency, use that instead
    if (typeof window.releaseAllKeysEmergency === 'function') {
        window.releaseAllKeysEmergency();
    }
}

// Start auto respawn functionality
function ar_startAutoRespawn() {
    // Clear any existing interval to prevent duplicates
    if (ar_scoreBoardInterval) {
        clearInterval(ar_scoreBoardInterval);
    }
    
    ar_scoreBoardInterval = setInterval(() => {
        if (!ar_secondScriptActive) return;
        
        const scoreboard = document.getElementById("scoreboard-new");
        if (scoreboard && scoreboard.offsetParent === null) {
            // Scoreboard not visible, so do nothing
            return;
        }
        
        const respawnButton = [...document.getElementsByTagName("button")]
            .filter(b => b.innerText.indexOf("Respawn [Space]") === 0)[0];
        
        if (respawnButton) {
            // Clear any existing timer
            if (ar_respawnTimer) clearTimeout(ar_respawnTimer);
            
            // Click the respawn button
            respawnButton.click();
            
            // Log the action
            if (typeof logActivity === 'function') {
                logActivity("–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π —Ä–µ—Å–ø–∞–≤–Ω –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω");
            } else {
                console.log("–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π —Ä–µ—Å–ø–∞–≤–Ω –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω");
            }
            
            // Visual feedback
            ar_flashStatus('#FFD700', 300);
            
            // Make sure all keys are released first
            ar_releaseAllKeys();
            
            // Set timer to press R after respawn if enabled
            if (ar_pressRAfterRespawn) {
                ar_respawnTimer = setTimeout(() => {
                    if (typeof logActivity === 'function') {
                        logActivity("–ù–∞–∂–∞—Ç–∞ –∫–ª–∞–≤–∏—à–∞ R");
                    } else {
                        console.log("–ù–∞–∂–∞—Ç–∞ –∫–ª–∞–≤–∏—à–∞ R");
                    }
                    
                    // Simulate R keypress
                    ar_simulateKeyDown(82); // R key
                    
                    // Release R key after a short delay
                    setTimeout(() => {
                        ar_simulateKeyUp(82);
                    }, 50);
                }, 1000); // 1 second after respawn
            }
        }
    }, 100);
}

// Stop auto respawn
function ar_stopAutoRespawn() {
    if (ar_scoreBoardInterval) {
        clearInterval(ar_scoreBoardInterval);
        ar_scoreBoardInterval = null;
    }
    
    if (ar_respawnTimer) {
        clearTimeout(ar_respawnTimer);
        ar_respawnTimer = null;
    }
}

// Key event listeners
document.addEventListener("keydown", (event) => {
    // Toggle auto respawn with X key (Latin 'x' or Cyrillic '—á')
    if (event.key === "x" || event.key === "X" || event.key === "—á" || event.key === "–ß") {
        ar_secondScriptActive = !ar_secondScriptActive;
        ar_updateStatus();
        
        if (typeof logActivity === 'function') {
            logActivity(`Auto Respawn ${ar_secondScriptActive ? 'enabled' : 'disabled'}`);
        } else {
            console.log(`Auto Respawn ${ar_secondScriptActive ? 'enabled' : 'disabled'}`);
        }
        
        if (ar_secondScriptActive) {
            ar_startAutoRespawn();
        } else {
            ar_stopAutoRespawn();
        }
    }
    
    // Toggle R key press after respawn with T key (Latin 't' or Cyrillic '–µ')
    if (event.key === "t" || event.key === "T" || event.key === "–µ" || event.key === "–ï") {
        ar_pressRAfterRespawn = !ar_pressRAfterRespawn;
        ar_updateStatus();
        
        if (typeof logActivity === 'function') {
            logActivity(`R key press after respawn ${ar_pressRAfterRespawn ? 'enabled' : 'disabled'}`);
        } else {
            console.log(`R key press after respawn ${ar_pressRAfterRespawn ? 'enabled' : 'disabled'}`);
        }
    }
});

// Clean up on page unload
window.addEventListener('beforeunload', () => {
    ar_stopAutoRespawn();
});

// Initialize
ar_createUI();
// Don't start auto respawn by default

// Extend the fixGameBot function if it exists
if (typeof window.fixGameBot !== 'undefined') {
    const originalFixGameBot = window.fixGameBot;
    window.fixGameBot = function() {
        // Call the original function
        const result = originalFixGameBot();
        
        // Re-add our UI and restart the auto respawn if needed
        ar_createUI();
        if (ar_secondScriptActive) {
            ar_startAutoRespawn();
        }
        
        return result + " Auto Respawn restored.";
    };
} else {
    // Create a new fixGameBot function if it doesn't exist
    window.fixGameBot = function() {
        ar_createUI();
        if (ar_secondScriptActive) {
            ar_startAutoRespawn();
        }
        return "Auto Respawn restored.";
    };
}

// Configurable Key Spam Addon with Russian Keyboard Support
// This addon automatically cycles through keys 1-4 when toggled on by pressing –ò/B
(function() {
    // State variables for the spam feature
    let spamActive = false;
    let spamInterval = null;
    const DEFAULT_SPAM_DELAY = 50; // Default ms between key presses
    let currentSpamDelay = DEFAULT_SPAM_DELAY;
    
    // Keys to cycle through (restricted to 1,2,3,4 only)
    let spamKeys = [
        { keyCode: 49, label: '1', active: true },
        { keyCode: 50, label: '2', active: true },
        { keyCode: 51, label: '3', active: true },
        { keyCode: 52, label: '4', active: true }
    ];
    
    // Create UI for key configuration
    function createSpamConfigUI() {
        const uiContainer = document.getElementById('bot-ui-container');
        if (!uiContainer) return;
        
        // Create config panel that will be shown/hidden
        const configPanel = document.createElement('div');
        configPanel.id = 'spam-config-panel';
        configPanel.style.cssText = `
            display: none;
            background-color: rgba(30, 30, 30, 0.95);
            padding: 10px;
            margin-top: 8px;
            border-radius: 4px;
            border: 1px solid #444;
        `;
        
        // Create key selection grid
        const keyGrid = document.createElement('div');
        keyGrid.style.cssText = `
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 5px;
            margin-bottom: 10px;
        `;
        
        // Add key toggle buttons
        spamKeys.forEach(key => {
            const keyButton = document.createElement('button');
            keyButton.textContent = key.label;
            keyButton.dataset.keyCode = key.keyCode;
            keyButton.style.cssText = `
                background-color: ${key.active ? '#4CAF50' : '#555'};
                color: white;
                border: none;
                border-radius: 4px;
                padding: 5px;
                cursor: pointer;
                font-weight: bold;
            `;
            
            keyButton.addEventListener('click', () => {
                // Toggle key active state
                const keyIndex = spamKeys.findIndex(k => k.keyCode === parseInt(keyButton.dataset.keyCode));
                if (keyIndex !== -1) {
                    spamKeys[keyIndex].active = !spamKeys[keyIndex].active;
                    keyButton.style.backgroundColor = spamKeys[keyIndex].active ? '#4CAF50' : '#555';
                    
                    // Update key sequence display
                    updateKeySequenceDisplay();
                    
                    // Save configuration
                    saveSpamConfig();
                    
                    // If spam is active, restart with new key configuration
                    if (spamActive) {
                        stopSpamming();
                        startSpamming();
                    }
                }
            });
            
            keyGrid.appendChild(keyButton);
        });
        
        configPanel.appendChild(keyGrid);
        
        // Add speed control
        const speedContainer = document.createElement('div');
        speedContainer.style.cssText = `
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        `;
        
        const speedLabel = document.createElement('span');
        speedLabel.textContent = 'Speed:';
        speedLabel.style.marginRight = '10px';
        
        const speedSlider = document.createElement('input');
        speedSlider.type = 'range';
        speedSlider.min = '20';
        speedSlider.max = '500';
        speedSlider.step = '10';
        speedSlider.value = currentSpamDelay.toString();
        speedSlider.style.flex = '1';
        
        const speedValue = document.createElement('span');
        speedValue.textContent = `${currentSpamDelay}ms`;
        speedValue.style.marginLeft = '10px';
        speedValue.style.minWidth = '45px';
        
        speedSlider.addEventListener('input', () => {
            currentSpamDelay = parseInt(speedSlider.value);
            speedValue.textContent = `${currentSpamDelay}ms`;
            
            // If spam is active, restart with new delay
            if (spamActive) {
                stopSpamming();
                startSpamming();
            }
            
            // Save configuration
            saveSpamConfig();
        });
        
        speedContainer.appendChild(speedLabel);
        speedContainer.appendChild(speedSlider);
        speedContainer.appendChild(speedValue);
        
        configPanel.appendChild(speedContainer);
        
        // Key sequence display
        const sequenceContainer = document.createElement('div');
        sequenceContainer.style.cssText = `
            margin-bottom: 10px;
        `;
        
        const sequenceLabel = document.createElement('div');
        sequenceLabel.textContent = 'Active sequence:';
        sequenceLabel.style.marginBottom = '5px';
        
        const sequenceDisplay = document.createElement('div');
        sequenceDisplay.id = 'key-sequence-display';
        sequenceDisplay.style.cssText = `
            padding: 5px;
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
            font-family: monospace;
        `;
        
        sequenceContainer.appendChild(sequenceLabel);
        sequenceContainer.appendChild(sequenceDisplay);
        configPanel.appendChild(sequenceContainer);
        
        // Add close button
        const closeButton = document.createElement('button');
        closeButton.textContent = 'Close';
        closeButton.style.cssText = `
            background-color: #666;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 5px 10px;
            cursor: pointer;
            width: 100%;
        `;
        
        closeButton.addEventListener('click', () => {
            configPanel.style.display = 'none';
        });
        
        configPanel.appendChild(closeButton);
        
        // Add config button to main UI
        const spamConfigButton = document.createElement('button');
        spamConfigButton.textContent = '‚öôÔ∏è';
        spamConfigButton.style.cssText = `
            background: transparent;
            border: none;
            color: white;
            font-size: 14px;
            cursor: pointer;
            padding: 2px 6px;
            margin-left: 5px;
        `;
        
        spamConfigButton.addEventListener('click', () => {
            configPanel.style.display = configPanel.style.display === 'none' ? 'block' : 'none';
            // Update key sequence display when opening
            if (configPanel.style.display === 'block') {
                updateKeySequenceDisplay();
            }
        });
        
        // Find the spam status element to place the config button next to it
        const spamStatusElement = document.getElementById('spam-status');
        if (spamStatusElement && spamStatusElement.parentNode) {
            spamStatusElement.parentNode.appendChild(spamConfigButton);
        }
        
        // Add the config panel to the container
        uiContainer.appendChild(configPanel);
        
        // Initial update of sequence display
        updateKeySequenceDisplay();
    }
    
    // Update the display showing which keys are in the sequence
    function updateKeySequenceDisplay() {
        const sequenceDisplay = document.getElementById('key-sequence-display');
        if (!sequenceDisplay) return;
        
        const activeKeys = spamKeys.filter(k => k.active).map(k => k.label);
        
        if (activeKeys.length === 0) {
            sequenceDisplay.textContent = 'No keys selected!';
            sequenceDisplay.style.color = '#F44336';
        } else {
            sequenceDisplay.textContent = activeKeys.join(' ‚Üí ');
            sequenceDisplay.style.color = '#FFFFFF';
        }
    }
    
    // Save spam configuration to localStorage
    function saveSpamConfig() {
        try {
            const config = {
                keys: spamKeys.map(k => ({ keyCode: k.keyCode, label: k.label, active: k.active })),
                delay: currentSpamDelay
            };
            
            localStorage.setItem('gameBotSpamConfig', JSON.stringify(config));
            logActivity("Spam configuration saved");
        } catch (e) {
            console.error("Failed to save spam configuration:", e);
        }
    }
    
    // Load spam configuration from localStorage
    function loadSpamConfig() {
        try {
            const savedConfig = localStorage.getItem('gameBotSpamConfig');
            if (savedConfig) {
                const config = JSON.parse(savedConfig);
                
                // Update spam keys with saved configuration (only for keys 1-4)
                if (config.keys && Array.isArray(config.keys)) {
                    config.keys.forEach(savedKey => {
                        // Only apply settings for key codes 49-52 (keys 1-4)
                        if (savedKey.keyCode >= 49 && savedKey.keyCode <= 52) {
                            const keyIndex = spamKeys.findIndex(k => k.keyCode === savedKey.keyCode);
                            if (keyIndex !== -1) {
                                spamKeys[keyIndex].active = savedKey.active;
                            }
                        }
                    });
                }
                
                // Update spam delay
                if (config.delay && typeof config.delay === 'number') {
                    currentSpamDelay = config.delay;
                }
                
                logActivity("Spam configuration loaded");
                
                // Update UI if it exists
                const speedSlider = document.querySelector('#spam-config-panel input[type="range"]');
                if (speedSlider) {
                    speedSlider.value = currentSpamDelay.toString();
                    const speedValue = speedSlider.nextElementSibling;
                    if (speedValue) {
                        speedValue.textContent = `${currentSpamDelay}ms`;
                    }
                }
                
                // Update key buttons
                spamKeys.forEach(key => {
                    const keyButton = document.querySelector(`#spam-config-panel button[data-key-code="${key.keyCode}"]`);
                    if (keyButton) {
                        keyButton.style.backgroundColor = key.active ? '#4CAF50' : '#555';
                    }
                });
                
                // Update sequence display
                updateKeySequenceDisplay();
            }
        } catch (e) {
            console.error("Failed to load spam configuration:", e);
        }
    }
    
    // Simulate key press (keydown + keyup)
    function simulateKeyPress(keyCode) {
        document.dispatchEvent(new KeyboardEvent("keydown", { keyCode: keyCode }));
        setTimeout(() => {
            document.dispatchEvent(new KeyboardEvent("keyup", { keyCode: keyCode }));
        }, 10); // Small delay between down and up
    }
    
    // Start spamming keys
    function startSpamming() {
        // Clear existing interval if running
        stopSpamming();
        
        // Get active keys
        const activeKeysCodes = spamKeys.filter(k => k.active).map(k => k.keyCode);
        
        // If no keys are selected, show a warning
        if (activeKeysCodes.length === 0) {
            logActivity("No keys selected for spam! Configure keys first.");
            spamActive = false;
            updateStatus('spam-status', false);
            return;
        }
        
        let index = 0;
        spamInterval = setInterval(() => {
            simulateKeyPress(activeKeysCodes[index]);
            index = (index + 1) % activeKeysCodes.length;
        }, currentSpamDelay);
        
        // Log the active keys
        const activeKeysLabels = spamKeys.filter(k => k.active).map(k => k.label).join(', ');
        logActivity(`Key spam activated - cycling keys: ${activeKeysLabels}`);
    }
    
    // Stop spamming keys
    function stopSpamming() {
        if (spamInterval) {
            clearInterval(spamInterval);
            spamInterval = null;
            logActivity("Key spam deactivated");
        }
    }
    
    // Initialize function for the addon
    function initialize() {
        // Try to load saved configuration
        loadSpamConfig();
        
        // Create the configuration UI
        createSpamConfigUI();
        
        // Start in deactivated state
        updateStatus('spam-status', spamActive);
        logActivity("Configurable Key Spam initialized (Keys 1-4 only)");
    }
    
    // Cleanup function
    function cleanup() {
        stopSpamming();
        spamActive = false;
        updateStatus('spam-status', false);
        logActivity("Key Spam disabled");
        
        // Remove config panel if it exists
        const configPanel = document.getElementById('spam-config-panel');
        if (configPanel) {
            configPanel.remove();
        }
    }
    
    // Toggle spam mode
    function toggleSpamMode() {
        spamActive = !spamActive;
        updateStatus('spam-status', spamActive);
        
        if (spamActive) {
            startSpamming();
        } else {
            stopSpamming();
        }
    }
    
    // Handle keydown events - support both Latin 'B' and Cyrillic '–ò' (which is on the same key as 'B')
    function onKeyDown(event) {
        // Check for both Latin 'b' and Cyrillic '–∏' (Russian B key)
        if (event.key.toLowerCase() === 'b' || event.key === '–∏' || event.key === '–ò') {
            toggleSpamMode();
        }
    }
    
    // Register the feature with the addon manager
    window.gameBotAddonManager.registerFeature('spam-status', {
        label: '–°–ø–∞–º –ü–µ—Ä–∫–∞–º–∏ (B/–ò)',
        initialActive: spamActive,
        initialize: initialize,
        cleanup: cleanup,
        onKeyDown: onKeyDown
    });
})();
/**
 * Auto Chain Addon - Rapidly places bombs when C key is held down
 * This addon properly integrates with the Game Bot Framework using the addon manager
 */

// Create module-level variables outside the addon object to solve 'this' context issues
let autoChain_active = false;
let autoChain_interval = null;

// Create UI for this functionality
function autoChain_createUI() {
    // Check if main UI container exists
    const botUiContainer = document.getElementById('bot-ui-container');
    if (!botUiContainer) {
        console.log("Main bot UI not found. Auto Chain will retry in 1 second.");
        setTimeout(autoChain_createUI, 1000);
        return;
    }
    
    // Remove any existing controls to prevent duplicates
    const existingControl = document.getElementById('auto-chain-status');
    if (existingControl && existingControl.parentElement) {
        existingControl.parentElement.remove();
    }
    
    // Create container
    const autoChainContainer = document.createElement('div');
    autoChainContainer.style.cssText = `
        display: flex;
        justify-content: space-between;
        margin-bottom: 8px;
        align-items: center;
    `;
    
    const autoChainLabel = document.createElement('span');
    autoChainLabel.textContent = '–¶–µ–ø—å (–î–µ—Ä–∂–∏—Ç–µ C)';
    
    const autoChainStatus = document.createElement('span');
    autoChainStatus.id = 'auto-chain-status';
    autoChainStatus.textContent = autoChain_active ? 'ON' : 'OFF';
    autoChainStatus.style.cssText = `
        font-weight: bold;
        color: ${autoChain_active ? '#4CAF50' : '#F44336'};
        background-color: rgba(0, 0, 0, 0.3);
        padding: 2px 6px;
        border-radius: 4px;
        transition: background-color 0.2s ease;
    `;
    
    autoChainContainer.appendChild(autoChainLabel);
    autoChainContainer.appendChild(autoChainStatus);
    
    // Find the movement UI to insert after it
    const movementStatusElement = document.getElementById('movement-status');
    let referenceNode = null;
    
    if (movementStatusElement) {
        // Find the parent div containing the movement status
        referenceNode = movementStatusElement.parentElement;
        if (referenceNode && referenceNode.nextSibling) {
            // Insert after the movement container
            botUiContainer.insertBefore(autoChainContainer, referenceNode.nextSibling);
        } else {
            // Fallback: insert after header
            const header = botUiContainer.querySelector('div:first-child');
            if (header && header.nextSibling) {
                botUiContainer.insertBefore(autoChainContainer, header.nextSibling);
            } else {
                // Last resort: append to container
                botUiContainer.appendChild(autoChainContainer);
            }
        }
    } else {
        // Movement UI not found, insert after header
        const header = botUiContainer.querySelector('div:first-child');
        if (header && header.nextSibling) {
            botUiContainer.insertBefore(autoChainContainer, header.nextSibling);
        } else {
            // Fallback: append to container
            botUiContainer.appendChild(autoChainContainer);
        }
    }
    
    // Log the addition
    if (typeof logActivity === 'function') {
        logActivity("Auto Chain UI added");
    } else {
        console.log("Auto Chain UI added");
    }
}

// Update auto chain status display
function autoChain_updateStatus() {
    const autoChainStatus = document.getElementById('auto-chain-status');
    if (autoChainStatus) {
        autoChainStatus.textContent = autoChain_active ? 'ON' : 'OFF';
        autoChainStatus.style.color = autoChain_active ? '#4CAF50' : '#F44336';
    }
}

// Flash effect for visual feedback - text color only, no background
function autoChain_flashStatus(duration = 100) {
    const element = document.getElementById('auto-chain-status');
    if (element) {
        const originalColor = element.style.color;
        element.style.color = '#FFFFFF';
        setTimeout(() => {
            element.style.color = originalColor;
        }, duration);
    }
}

// Function to start the auto chain bomb spam
function autoChain_startSpamming() {
    // Stop any existing interval first
    autoChain_stopSpamming();
    
    // Start new interval
    autoChain_interval = setInterval(() => {
        if (autoChain_active) {
            // Simulate K keypress (place bomb) as fast as possible
            document.dispatchEvent(new KeyboardEvent("keydown", { keyCode: 75, key: "k" }));
            
            // Update activeKeys if available
            if (typeof window.activeKeys !== 'undefined') {
                window.activeKeys.add(75);
                if (typeof window.updateActiveKeysDisplay === 'function') {
                    window.updateActiveKeysDisplay();
                }
            }
            
            // Release K key immediately for rapid spam
            setTimeout(() => {
                document.dispatchEvent(new KeyboardEvent("keyup", { keyCode: 75, key: "k" }));
                
                // Update activeKeys if available
                if (typeof window.activeKeys !== 'undefined') {
                    window.activeKeys.delete(75);
                    if (typeof window.updateActiveKeysDisplay === 'function') {
                        window.updateActiveKeysDisplay();
                    }
                }
            }, 10);
        }
    }, 20); // 20ms interval for very fast bomb spam
    
    if (typeof logActivity === 'function') {
        logActivity("Auto Chain spam started");
    } else {
        console.log("Auto Chain spam started");
    }
}

// Function to stop the auto chain bomb spam
function autoChain_stopSpamming() {
    if (autoChain_interval) {
        clearInterval(autoChain_interval);
        autoChain_interval = null;
    }
}

// Activate Auto Chain when C key is pressed down
document.addEventListener("keydown", (event) => {
   if ((event.key === "c" || event.key === "C" || event.key === "—Å" || event.key === "–°") && !autoChain_active) {
        autoChain_active = true;
        autoChain_updateStatus();
        autoChain_flashStatus();
        
        if (typeof logActivity === 'function') {
            logActivity("Auto Chain activated (holding)");
        } else {
            console.log("Auto Chain activated (holding)");
        }
        
        autoChain_startSpamming(); // Start bombing
    }
});

// Deactivate Auto Chain when C key is released
document.addEventListener("keyup", (event) => {
    if (event.key === "c" || event.key === "C" || event.key === "—Å" || event.key === "–°") {
        autoChain_active = false;
        autoChain_updateStatus();
        
        if (typeof logActivity === 'function') {
            logActivity("Auto Chain deactivated (released)");
        } else {
            console.log("Auto Chain deactivated (released)");
        }
        
        autoChain_stopSpamming(); // Stop bombing
    }
});

// Clean up on page unload
window.addEventListener('beforeunload', () => {
    autoChain_stopSpamming();
});

// Initialize
autoChain_createUI();

// Extend the fixGameBot function if it exists
if (typeof window.fixGameBot !== 'undefined') {
    const originalFixGameBot = window.fixGameBot;
    window.fixGameBot = function() {
        // Call the original function
        const result = originalFixGameBot();
        
        // Re-add our UI
        autoChain_createUI();
        
        return result + " Auto Chain restored.";
    };
} else {
    // Create a new fixGameBot function if it doesn't exist
    window.fixGameBot = function() {
        autoChain_createUI();
        return "Auto Chain restored.";
    };
}

// Log that the script has loaded
console.log('[Auto Chain Addon - Hold Version] Loaded successfully!');
// Chat Mode Addon
// This addon prevents keyboard shortcuts from toggling bot features when you're in chat

// Flag to track if chat mode is active
let chatModeActive = false;

// Register the Chat Mode feature with the addon manager
window.gameBotAddonManager.registerFeature("chatMode", {
    label: "–†–µ–∂–∏–º –ß–∞—Ç–∞",
    initialActive: false,
    
    // Initialize the feature
    initialize: function() {
        // Create the chat mode toggle button
        const uiContainer = document.getElementById('bot-ui-container');
        if (!uiContainer) return;
        
        // Add a Chat Mode toggle button
        const chatModeButton = document.createElement('button');
        chatModeButton.id = 'chat-mode-button';
        chatModeButton.textContent = '–í–∫–ª—é—á–∏—Ç—å –†–µ–∂–∏–º –ß–∞—Ç–∞';
        chatModeButton.style.cssText = `
            background-color: #4b6584;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 5px 10px;
            margin: 10px 0;
            cursor: pointer;
            width: 100%;
            font-weight: bold;
            transition: background-color 0.2s ease;
        `;
        
        chatModeButton.addEventListener('click', function() {
            toggleChatMode();
        });
        
        // Find the log container to insert before it
        const logContainer = document.querySelector('#bot-ui-container div[style*="border-top"]');
        if (logContainer) {
            uiContainer.insertBefore(chatModeButton, logContainer);
        } else {
            // Otherwise just append to the end of the container
            uiContainer.appendChild(chatModeButton);
        }
        
        // Log initialization
        logActivity("–ê–¥–¥–æ–Ω –†–µ–∂–∏–º–∞ –ß–∞—Ç–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω");
    },
    
    // Cleanup function
    cleanup: function() {
        // Ensure chat mode is disabled when cleaning up
        chatModeActive = false;
        updateChatModeUI();
    },
    
    // We don't need to handle key events directly in this addon
    onKeyDown: function(event) {},
    onKeyUp: function(event) {}
});

// Function to toggle chat mode
function toggleChatMode() {
    chatModeActive = !chatModeActive;
    updateChatModeUI();
    logActivity(`–†–µ–∂–∏–º –ß–∞—Ç–∞ ${chatModeActive ? '–≤–∫–ª—é—á–µ–Ω' : '–≤—ã–∫–ª—é—á–µ–Ω'}`);
}

// Update the UI to reflect chat mode status
function updateChatModeUI() {
    const chatModeButton = document.getElementById('chat-mode-button');
    if (chatModeButton) {
        chatModeButton.textContent = chatModeActive ? '–í—ã–∫–ª—é—á–∏—Ç—å –†–µ–∂–∏–º –ß–∞—Ç–∞' : '–í–∫–ª—é—á–∏—Ç—å –†–µ–∂–∏–º –ß–∞—Ç–∞';
        chatModeButton.style.backgroundColor = chatModeActive ? '#eb3b5a' : '#4b6584';
    }
    
    updateStatus('chatMode', chatModeActive);
}

// Create a high-priority event handler that intercepts ALL keyboard events
// We'll add this before any other event handlers
let originalKeydownHandler = null;
let originalKeyupHandler = null;

// Store the original document event handlers
if (document.onkeydown) {
    originalKeydownHandler = document.onkeydown;
}
if (document.onkeyup) {
    originalKeyupHandler = document.onkeyup;
}

// Allowed keys that should pass through even when Chat Mode is active
const ALLOWED_KEYCODES = [
    119,  // F8 for toggling chat mode
    13,   // Enter key for sending messages
    9,    // Tab key for navigation
    16,   // Shift
    17,   // Ctrl
    18,   // Alt
    20,   // Caps Lock
    27,   // Escape
    33,   // Page Up
    34,   // Page Down
    35,   // End
    36,   // Home
    37,   // Left Arrow
    38,   // Up Arrow
    39,   // Right Arrow
    40,   // Down Arrow
    45,   // Insert
    46,   // Delete
    8,    // Backspace
    91,   // Left Windows/Command key
    93,   // Right Windows/Command key
    112,  // F1
    113,  // F2
    114,  // F3
    115,  // F4
    116,  // F5
    117,  // F6
    118,  // F7
    120,  // F9
    121,  // F10
    122,  // F11
    123   // F12
];

// Add our own handlers that run first
document.onkeydown = function(event) {
    // If chat mode is active, block keyboard events except allowed keys
    if (chatModeActive) {
        // Check if this is an allowed key
        if (ALLOWED_KEYCODES.includes(event.keyCode)) {
            // Continue with the event
        } else {
            // Block this event
            event.stopImmediatePropagation();
            // Still allow default browser behavior for normal typing
            return true;
        }
    }
    
    // Call the original handler if it existed
    if (originalKeydownHandler) {
        return originalKeydownHandler(event);
    }
};

document.onkeyup = function(event) {
    // If chat mode is active, block keyboard events except allowed keys
    if (chatModeActive) {
        // Check if this is an allowed key
        if (ALLOWED_KEYCODES.includes(event.keyCode)) {
            // Continue with the event
        } else {
            // Block this event
            event.stopImmediatePropagation();
            // Still allow default browser behavior for normal typing
            return true;
        }
    }
    
    // Call the original handler if it existed
    if (originalKeyupHandler) {
        return originalKeyupHandler(event);
    }
};

// Additionally, inject a capture-phase listener that runs before any other listeners
document.addEventListener('keydown', function(event) {
    // If chat mode is active, fully block events except allowed keys
    if (chatModeActive && !ALLOWED_KEYCODES.includes(event.keyCode)) {
        // Log blocked keys (only for keydown to avoid duplicate logs)
        logActivity(`–ö–ª–∞–≤–∏—à–∞ –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–∞: ${event.key || event.keyCode} (–†–µ–∂–∏–º –ß–∞—Ç–∞ –∞–∫—Ç–∏–≤–µ–Ω)`);
        
        // Block the event
        event.stopImmediatePropagation();
        event.stopPropagation();
    }
}, true); // true = capture phase, runs before bubbling phase

document.addEventListener('keyup', function(event) {
    // If chat mode is active, fully block events except allowed keys
    if (chatModeActive && !ALLOWED_KEYCODES.includes(event.keyCode)) {
        // Block the event
        event.stopImmediatePropagation();
        event.stopPropagation();
    }
}, true); // true = capture phase, runs before bubbling phase

// Fully override the existing key handlers in addon manager
const originalDocAddEventListener = document.addEventListener;
document.addEventListener = function(type, listener, options) {
    if ((type === "keydown" || type === "keyup") && typeof listener === 'function') {
        const wrappedListener = function(event) {
            // If chat mode is active, only call for allowed keys
            if (chatModeActive && !ALLOWED_KEYCODES.includes(event.keyCode)) {
                return;
            }
            
            // Call the original listener
            return listener.call(this, event);
        };
        
        // Call the original addEventListener with our wrapped listener
        return originalDocAddEventListener.call(this, type, wrappedListener, options);
    } else {
        // For non-keyboard events, just pass through
        return originalDocAddEventListener.call(this, type, listener, options);
    }
};

// Add a shortcut key to toggle chat mode (F8)
document.addEventListener('keydown', function(event) {
    // Use F8 as a shortcut to toggle chat mode (keyCode 119)
    if (event.keyCode === 119) {
        toggleChatMode();
        event.preventDefault();
    }
});

// Add an indicator to the UI
addFeatureToUI("chatMode", "–†–µ–∂–∏–º –ß–∞—Ç–∞", chatModeActive);

// Initialize Chat Mode
logActivity("–ê–¥–¥–æ–Ω –†–µ–∂–∏–º–∞ –ß–∞—Ç–∞ –≥–æ—Ç–æ–≤ - –Ω–∞–∂–º–∏—Ç–µ F8 –∏–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–Ω–æ–ø–∫—É –¥–ª—è –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏—è");


