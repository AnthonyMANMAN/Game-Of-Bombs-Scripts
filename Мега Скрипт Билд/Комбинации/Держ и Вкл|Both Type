/**
 * Unified Game Bot Addons
 * This script combines the following addons that integrate with the Game Bot Framework:
 * 1. Auto Chain - Hold J/Й or toggle with C/С to automatically spam K/К key
 * 2. Rotation Mode - Toggle with N/Т to automatically rotate movement
 * 3. Configurable Key Spam - Advanced version with UI controls for keys 1-4
 * 
 * Enhanced with Russian keyboard layout support
 */

// ========== AUTO CHAIN ADDON SECTION ==========
// Module-level variables for Auto Chain feature
let autoChain_active = false;
let autoChain_interval = null;
let autoChain_holdActive = false; // For hold-to-activate mode with J/Й key

// ========== ROTATION ADDON SECTION ==========
// Module-level variables for Rotation feature
let rotationAddon_inProgress = false;
let rotationAddon_interval = null;
let rotationAddon_active = false;

// ========== CONFIGURABLE KEY SPAM SECTION ==========
// State variables for the configurable spam feature
let configSpam_active = false;
let configSpam_interval = null;
const DEFAULT_SPAM_DELAY = 50; // Default ms between key presses
let currentSpamDelay = DEFAULT_SPAM_DELAY;

// Keys to cycle through (restricted to 1,2,3,4 only)
let spamKeys = [
    { keyCode: 49, label: '1', active: true },
    { keyCode: 50, label: '2', active: true },
    { keyCode: 51, label: '3', active: true },
    { keyCode: 52, label: '4', active: true }
];

// ========== KEYBOARD LAYOUT MAPPINGS ==========
const keyboardMappings = {
    // Auto Chain keys
    'c': ['c', 'C', 'с', 'С'], // C/С (English/Russian)
    'j': ['j', 'J', 'о', 'О'], // J/О (correct mapping for ЙЦУКЕН)
    'k': ['k', 'K', 'к', 'К'], // K/К
    
    // Rotation key
    'n': ['n', 'N', 'т', 'Т'], // N/Т
    
    // Configurable Key Spam toggle
    'b': ['b', 'B', 'и', 'И'], // B/И

    
    // For arrow keys we don't need mappings as they're the same on any layout
};

// Helper function to check if a key matches any variant
function keyMatches(pressedKey, keyType) {
    if (!keyboardMappings[keyType]) return false;
    return keyboardMappings[keyType].includes(pressedKey);
}

// ========== COMBINED ADDONS INITIALIZATION ==========
(function initializeCombinedAddons() {
    // Make sure the base framework is loaded first
    if (!window.gameBotAddonManager) {
        console.log("Game Bot Framework not found. Retrying in 1 second...");
        setTimeout(initializeCombinedAddons, 1000);
        return;
    }

    // ===== AUTO CHAIN FEATURE =====
    // Register Auto Chain feature with the addon manager
    window.gameBotAddonManager.registerFeature('auto-chain-status', {
        label: 'Цепь С(Вкл)/Й(Держ)',
        initialActive: false,
        
        // Initialize the Auto Chain feature
        initialize: function() {
            autoChain_active = false;
            autoChain_holdActive = false;
            logActivity("Auto Chain addon initialized - use 'C/С' to toggle or hold 'J/Й' to activate");
        },
        
        // Cleanup when the Auto Chain is disabled
        cleanup: function() {
            autoChain_stopSpamming();
            logActivity("Auto Chain addon cleanup complete");
        },
        
        // Handle keydown events for Auto Chain
        onKeyDown: function(event) {
            // Toggle with C/С key (English/Russian)
            if (keyMatches(event.key, 'c')) {
                autoChain_active = !autoChain_active;
                this.active = autoChain_active || autoChain_holdActive;
                updateStatus('auto-chain-status', autoChain_active || autoChain_holdActive);
                
                if (autoChain_active) {
                    logActivity("Auto Chain enabled (toggle mode)");
                    // Only start spamming if not already spamming from hold mode
                    if (!autoChain_holdActive) {
                        autoChain_startSpamming();
                    }
                } else {
                    logActivity("Auto Chain disabled (toggle mode)");
                    // Only stop spamming if hold mode is also inactive
                    if (!autoChain_holdActive) {
                        autoChain_stopSpamming();
                    }
                }
            }
            
            // Hold-to-activate with J/Й key (English/Russian)
            if (keyMatches(event.key, 'j')) {
                // Only set holdActive if it wasn't already true
                if (!autoChain_holdActive) {
                    autoChain_holdActive = true;
                    this.active = true;
                    updateStatus('auto-chain-status', true);
                    logActivity("Auto Chain enabled (hold mode)");
                    
                    // Only start spamming if it's not already running from toggle mode
                    if (!autoChain_interval) {
                        autoChain_startSpamming();
                    }
                }
            }
        },
        
        // Handle keyup events for Auto Chain
        onKeyUp: function(event) {
            // Release for J/Й key (hold mode)
            if (keyMatches(event.key, 'j')) {
                // Only update if holdActive was true
                if (autoChain_holdActive) {
                    autoChain_holdActive = false;
                    // Only update active status and stop spamming if toggle mode is also inactive
                    if (!autoChain_active) {
                        this.active = false;
                        updateStatus('auto-chain-status', false);
                        autoChain_stopSpamming();
                        logActivity("Auto Chain disabled (hold mode released)");
                    }
                }
            }
        }
    });

    // ===== ROTATION FEATURE =====
    // Register Rotation addon with the addon manager
    window.gameBotAddonManager.registerFeature('rotationAddon', {
        label: 'Режим Вращения (N/Т)',
        initialActive: rotationAddon_active,
        
        // Initialize the Rotation addon
        initialize: function() {
            rotationAddon_active = this.active;
            if (rotationAddon_active) {
                rotationAddon_performRotation();
            }
            logActivity("Rotation addon initialized - use 'N/Т' key to toggle");
        },
        
        // Cleanup when the Rotation addon is disabled
        cleanup: function() {
            rotationAddon_stopRotation();
            logActivity("Rotation addon cleanup complete");
        },
        
        // Handle keydown events for Rotation
        onKeyDown: function(event) {
            // Toggle rotation mode with N/Т key (English/Russian)
            if (keyMatches(event.key, 'n')) {
                rotationAddon_active = !rotationAddon_active;
                this.active = rotationAddon_active;
                updateStatus('rotationAddon', rotationAddon_active);
                
                // Start or stop rotation based on active state
                if (rotationAddon_active) {
                    rotationAddon_performRotation();
                    logActivity("Rotation mode activated - continuous rotation until toggled off");
                } else {
                    rotationAddon_stopRotation();
                    logActivity("Rotation mode deactivated");
                }
            }
        },
        
        // Required by framework but not used for this feature
        onKeyUp: function(event) {
            // No special handling needed for keyup events
        }
    });

    // ===== CONFIGURABLE KEY SPAM FEATURE =====
    // Register Configurable Key Spam feature with the addon manager
    window.gameBotAddonManager.registerFeature('config-spam-status', {
        label: 'Key Spam (B/И)',
        initialActive: configSpam_active,
        
        // Initialize the Configurable Key Spam feature
        initialize: function() {
            // Try to load saved configuration
            loadSpamConfig();
            
            // Create the configuration UI
            createSpamConfigUI();
            
            configSpam_active = this.active;
            if (configSpam_active) {
                startConfigSpamming();
            }
            
            updateStatus('config-spam-status', configSpam_active);
            logActivity("Configurable Key Spam initialized (Keys 1-4 only)");
        },
        
        // Cleanup when the Configurable Key Spam is disabled
        cleanup: function() {
            stopConfigSpamming();
            configSpam_active = false;
            updateStatus('config-spam-status', false);
            
            // Remove config panel if it exists
            const configPanel = document.getElementById('spam-config-panel');
            if (configPanel) {
                configPanel.remove();
            }
            
            logActivity("Configurable Key Spam cleaned up");
        },
        
        // Handle keydown events for Configurable Key Spam
        onKeyDown: function(event) {
            // Check for both B/И key (English/Russian)
            if (keyMatches(event.key, 'b')) {
                configSpam_active = !configSpam_active;
                this.active = configSpam_active;
                updateStatus('config-spam-status', configSpam_active);
                
                if (configSpam_active) {
                    startConfigSpamming();
                } else {
                    stopConfigSpamming();
                }
            }
        },
        
        // Required by framework but not used for this feature
        onKeyUp: function(event) {
            // No special handling needed for keyup events
        }
    });

    // Log that all addons have been loaded
    logActivity("Combined addons loaded successfully with Russian keyboard support");
})();

// ========== AUTO CHAIN FUNCTIONS ==========
// Function to start the auto chain bomb spam
function autoChain_startSpamming() {
    // Stop any existing interval first
    autoChain_stopSpamming();
    
    // Start new interval
    autoChain_interval = setInterval(() => {
        if (autoChain_active || autoChain_holdActive) {
            // Simulate K/К keypress (place bomb) as fast as possible
            // We'll use the keyCode to ensure it works regardless of layout
            document.dispatchEvent(new KeyboardEvent("keydown", { keyCode: 75, key: "k" }));
            
            // Update activeKeys if available
            if (typeof window.activeKeys !== 'undefined') {
                window.activeKeys.add(75);
                if (typeof window.updateActiveKeysDisplay === 'function') {
                    window.updateActiveKeysDisplay();
                }
            }
            
            // Release K/К key immediately for rapid spam
            setTimeout(() => {
                document.dispatchEvent(new KeyboardEvent("keyup", { keyCode: 75, key: "k" }));
                
                // Update activeKeys if available
                if (typeof window.activeKeys !== 'undefined') {
                    window.activeKeys.delete(75);
                    if (typeof window.updateActiveKeysDisplay === 'function') {
                        window.updateActiveKeysDisplay();
                    }
                }
            }, 10);
        }
    }, 20); // 20ms interval for very fast bomb spam
}

// Function to stop the auto chain bomb spam
function autoChain_stopSpamming() {
    if (autoChain_interval) {
        clearInterval(autoChain_interval);
        autoChain_interval = null;
    }
}

// ========== ROTATION FUNCTIONS ==========
// Function to perform rotation movement pattern
function rotationAddon_performRotation() {
    if (!rotationAddon_active) return;
    
    // Only start if not already in progress
    if (rotationAddon_inProgress) return;
    
    rotationAddon_inProgress = true;
    
    let currentStep = 0;
    // W(up), A(left), S(down), D(right), S(down), A(left) translated to arrow key codes
    // Note: Using arrow key codes which are universal across keyboard layouts
    const sequenceKeys = [38, 37, 40, 39, 40, 37];
    
    rotationAddon_interval = setInterval(() => {
        // Use the framework's key simulation functions
        simulateKeyDown(sequenceKeys[currentStep]);
        
        setTimeout(() => {
            simulateKeyUp(sequenceKeys[currentStep]);
            currentStep = (currentStep + 1) % 6; // Cycle through all 6 steps
        }, 5);
    }, 100);
}

// Function to stop rotation
function rotationAddon_stopRotation() {
    if (rotationAddon_interval) {
        clearInterval(rotationAddon_interval);
        rotationAddon_interval = null;
    }
    
    rotationAddon_inProgress = false;
    
    // Release all arrow keys if they're being held
    [37, 38, 39, 40].forEach(keyCode => {
        simulateKeyUp(keyCode);
    });
}

// ========== CONFIGURABLE KEY SPAM FUNCTIONS ==========
// Create UI for key configuration
function createSpamConfigUI() {
    const uiContainer = document.getElementById('bot-ui-container');
    if (!uiContainer) return;
    
    // Create config panel that will be shown/hidden
    const configPanel = document.createElement('div');
    configPanel.id = 'spam-config-panel';
    configPanel.style.cssText = `
        display: none;
        background-color: rgba(30, 30, 30, 0.95);
        padding: 10px;
        margin-top: 8px;
        border-radius: 4px;
        border: 1px solid #444;
    `;
    
    // Create key selection grid
    const keyGrid = document.createElement('div');
    keyGrid.style.cssText = `
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        gap: 5px;
        margin-bottom: 10px;
    `;
    
    // Add key toggle buttons
    spamKeys.forEach(key => {
        const keyButton = document.createElement('button');
        keyButton.textContent = key.label;
        keyButton.dataset.keyCode = key.keyCode;
        keyButton.style.cssText = `
            background-color: ${key.active ? '#4CAF50' : '#555'};
            color: white;
            border: none;
            border-radius: 4px;
            padding: 5px;
            cursor: pointer;
            font-weight: bold;
        `;
        
        keyButton.addEventListener('click', () => {
            // Toggle key active state
            const keyIndex = spamKeys.findIndex(k => k.keyCode === parseInt(keyButton.dataset.keyCode));
            if (keyIndex !== -1) {
                spamKeys[keyIndex].active = !spamKeys[keyIndex].active;
                keyButton.style.backgroundColor = spamKeys[keyIndex].active ? '#4CAF50' : '#555';
                
                // Update key sequence display
                updateKeySequenceDisplay();
                
                // Save configuration
                saveSpamConfig();
                
                // If spam is active, restart with new key configuration
                if (configSpam_active) {
                    stopConfigSpamming();
                    startConfigSpamming();
                }
            }
        });
        
        keyGrid.appendChild(keyButton);
    });
    
    configPanel.appendChild(keyGrid);
    
    // Add speed control
    const speedContainer = document.createElement('div');
    speedContainer.style.cssText = `
        display: flex;
        align-items: center;
        margin-bottom: 10px;
    `;
    
    const speedLabel = document.createElement('span');
    speedLabel.textContent = 'Speed:';
    speedLabel.style.marginRight = '10px';
    
    const speedSlider = document.createElement('input');
    speedSlider.type = 'range';
    speedSlider.min = '20';
    speedSlider.max = '500';
    speedSlider.step = '10';
    speedSlider.value = currentSpamDelay.toString();
    speedSlider.style.flex = '1';
    
    const speedValue = document.createElement('span');
    speedValue.textContent = `${currentSpamDelay}ms`;
    speedValue.style.marginLeft = '10px';
    speedValue.style.minWidth = '45px';
    
    speedSlider.addEventListener('input', () => {
        currentSpamDelay = parseInt(speedSlider.value);
        speedValue.textContent = `${currentSpamDelay}ms`;
        
        // If spam is active, restart with new delay
        if (configSpam_active) {
            stopConfigSpamming();
            startConfigSpamming();
        }
        
        // Save configuration
        saveSpamConfig();
    });
    
    speedContainer.appendChild(speedLabel);
    speedContainer.appendChild(speedSlider);
    speedContainer.appendChild(speedValue);
    
    configPanel.appendChild(speedContainer);
    
    // Key sequence display
    const sequenceContainer = document.createElement('div');
    sequenceContainer.style.cssText = `
        margin-bottom: 10px;
    `;
    
    const sequenceLabel = document.createElement('div');
    sequenceLabel.textContent = 'Active sequence:';
    sequenceLabel.style.marginBottom = '5px';
    
    const sequenceDisplay = document.createElement('div');
    sequenceDisplay.id = 'key-sequence-display';
    sequenceDisplay.style.cssText = `
        padding: 5px;
        background-color: rgba(0, 0, 0, 0.2);
        border-radius: 4px;
        font-family: monospace;
    `;
    
    sequenceContainer.appendChild(sequenceLabel);
    sequenceContainer.appendChild(sequenceDisplay);
    configPanel.appendChild(sequenceContainer);
    
    // Add close button
    const closeButton = document.createElement('button');
    closeButton.textContent = 'Close';
    closeButton.style.cssText = `
        background-color: #666;
        color: white;
        border: none;
        border-radius: 4px;
        padding: 5px 10px;
        cursor: pointer;
        width: 100%;
    `;
    
    closeButton.addEventListener('click', () => {
        configPanel.style.display = 'none';
    });
    
    configPanel.appendChild(closeButton);
    
    // Add config button to main UI
    const spamConfigButton = document.createElement('button');
    spamConfigButton.textContent = '⚙️';
    spamConfigButton.style.cssText = `
        background: transparent;
        border: none;
        color: white;
        font-size: 14px;
        cursor: pointer;
        padding: 2px 6px;
        margin-left: 5px;
    `;
    
    spamConfigButton.addEventListener('click', () => {
        configPanel.style.display = configPanel.style.display === 'none' ? 'block' : 'none';
        // Update key sequence display when opening
        if (configPanel.style.display === 'block') {
            updateKeySequenceDisplay();
        }
    });
    
    // Find the spam status element to place the config button next to it
    const spamStatusElement = document.getElementById('config-spam-status');
    if (spamStatusElement && spamStatusElement.parentNode) {
        spamStatusElement.parentNode.appendChild(spamConfigButton);
    }
    
    // Add the config panel to the container
    uiContainer.appendChild(configPanel);
    
    // Initial update of sequence display
    updateKeySequenceDisplay();
}

// Update the display showing which keys are in the sequence
function updateKeySequenceDisplay() {
    const sequenceDisplay = document.getElementById('key-sequence-display');
    if (!sequenceDisplay) return;
    
    const activeKeys = spamKeys.filter(k => k.active).map(k => k.label);
    
    if (activeKeys.length === 0) {
        sequenceDisplay.textContent = 'No keys selected!';
        sequenceDisplay.style.color = '#F44336';
    } else {
        sequenceDisplay.textContent = activeKeys.join(' → ');
        sequenceDisplay.style.color = '#FFFFFF';
    }
}

// Save spam configuration to localStorage
function saveSpamConfig() {
    try {
        const config = {
            keys: spamKeys.map(k => ({ keyCode: k.keyCode, label: k.label, active: k.active })),
            delay: currentSpamDelay
        };
        
        localStorage.setItem('gameBotSpamConfig', JSON.stringify(config));
        logActivity("Spam configuration saved");
    } catch (e) {
        console.error("Failed to save spam configuration:", e);
    }
}

// Load spam configuration from localStorage
function loadSpamConfig() {
    try {
        const savedConfig = localStorage.getItem('gameBotSpamConfig');
        if (savedConfig) {
            const config = JSON.parse(savedConfig);
            
            // Update spam keys with saved configuration (only for keys 1-4)
            if (config.keys && Array.isArray(config.keys)) {
                config.keys.forEach(savedKey => {
                    // Only apply settings for key codes 49-52 (keys 1-4)
                    if (savedKey.keyCode >= 49 && savedKey.keyCode <= 52) {
                        const keyIndex = spamKeys.findIndex(k => k.keyCode === savedKey.keyCode);
                        if (keyIndex !== -1) {
                            spamKeys[keyIndex].active = savedKey.active;
                        }
                    }
                });
            }
            
            // Update spam delay
            if (config.delay && typeof config.delay === 'number') {
                currentSpamDelay = config.delay;
            }
            
            logActivity("Spam configuration loaded");
            
            // Update UI if it exists
            const speedSlider = document.querySelector('#spam-config-panel input[type="range"]');
            if (speedSlider) {
                speedSlider.value = currentSpamDelay.toString();
                const speedValue = speedSlider.nextElementSibling;
                if (speedValue) {
                    speedValue.textContent = `${currentSpamDelay}ms`;
                }
            }
            
            // Update key buttons
            spamKeys.forEach(key => {
                const keyButton = document.querySelector(`#spam-config-panel button[data-key-code="${key.keyCode}"]`);
                if (keyButton) {
                    keyButton.style.backgroundColor = key.active ? '#4CAF50' : '#555';
                }
            });
            
            // Update sequence display
            updateKeySequenceDisplay();
        }
    } catch (e) {
        console.error("Failed to load spam configuration:", e);
    }
}

// Simulate key press (keydown + keyup) for configurable spam
function simulateConfigKeyPress(keyCode) {
    document.dispatchEvent(new KeyboardEvent("keydown", { keyCode: keyCode }));
    setTimeout(() => {
        document.dispatchEvent(new KeyboardEvent("keyup", { keyCode: keyCode }));
    }, 10); // Small delay between down and up
}

// Start spamming keys for configurable spam
function startConfigSpamming() {
    // Clear existing interval if running
    stopConfigSpamming();
    
    // Get active keys
    const activeKeysCodes = spamKeys.filter(k => k.active).map(k => k.keyCode);
    
    // If no keys are selected, show a warning
    if (activeKeysCodes.length === 0) {
        logActivity("No keys selected for spam! Configure keys first.");
        configSpam_active = false;
        updateStatus('config-spam-status', false);
        return;
    }
    
    let index = 0;
    configSpam_interval = setInterval(() => {
        simulateConfigKeyPress(activeKeysCodes[index]);
        index = (index + 1) % activeKeysCodes.length;
    }, currentSpamDelay);
    
    // Log the active keys
    const activeKeysLabels = spamKeys.filter(k => k.active).map(k => k.label).join(', ');
    logActivity(`Key spam activated - cycling keys: ${activeKeysLabels}`);
}

// Stop spamming keys for configurable spam
function stopConfigSpamming() {
    if (configSpam_interval) {
        clearInterval(configSpam_interval);
        configSpam_interval = null;
        logActivity("Key spam deactivated");
    }
}

// Function to simulate key down (helper)
function simulateKeyDown(keyCode) {
    document.dispatchEvent(new KeyboardEvent("keydown", { keyCode: keyCode }));
    // Update activeKeys if available
    if (typeof window.activeKeys !== 'undefined') {
        window.activeKeys.add(keyCode);
        if (typeof window.updateActiveKeysDisplay === 'function') {
            window.updateActiveKeysDisplay();
        }
    }
}

// Function to simulate key up (helper)
function simulateKeyUp(keyCode) {
    document.dispatchEvent(new KeyboardEvent("keyup", { keyCode: keyCode }));
    // Update activeKeys if available
    if (typeof window.activeKeys !== 'undefined') {
        window.activeKeys.delete(keyCode);
        if (typeof window.updateActiveKeysDisplay === 'function') {
            window.updateActiveKeysDisplay();
        }
    }
}

// ========== UTILITY FUNCTION FOR ACTIVITY LOGGING ==========
// Make sure there's a logging function
function logActivity(message) {
    if (typeof window.logBotActivity === 'function') {
        window.logBotActivity(message);
    } else {
        console.log('[Game Bot Addon]', message);
    }
}

// Make sure there's a status update function
function updateStatus(id, isActive) {
    if (typeof window.updateFeatureStatus === 'function') {
        window.updateFeatureStatus(id, isActive);
    } else {
        console.log(`[Status Update] ${id}: ${isActive ? 'active' : 'inactive'}`);
    }
}

// ========== EXTENDED FIX FUNCTION ==========
// Extend the fixGameBot function to restore all addons
(function() {
    // Store the original fixGameBot function if it exists
    const originalFixGameBot = window.fixGameBot || function() {
        return "Game bot fixed.";
    };
    
    // Override with our extended version
    window.fixGameBot = function() {
        // Call the original function
        const result = originalFixGameBot();
        
        // Restore all addons
        for (const id in window.gameBotAddonManager.features) {
            const feature = window.gameBotAddonManager.features[id];
            try {
                // Re-initialize the feature
                feature.initialize();
            } catch (e) {
                console.error(`Error reinitializing ${id}:`, e);
            }
        }
        
        logActivity("All addons restored successfully");
        return result + " All addons restored.";
    };
})();

// Log that the script has loaded
console.log('[Combined Addons] Loaded successfully with Russian keyboard support!');

