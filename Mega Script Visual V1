// Original script with visual UI added
// Global variables for script control
let active = true; // Toggle state for the original script
let firstScriptActive = false;
let secondScriptActive = true; // Auto-respawn enabled by default
let bombSpamActive = false;
let bombSpamInterval = null;
let moveTimeout = null;
let currentDirection = null;
let respawnTimer = null;
let scoreBoardInterval = null;
let isToggling = false; // Flag to prevent duplicate toggling
let bombInterval = null; // Interval for spamming "K"

// Define key codes
const ee = {
    up: { keyCode: 87, key: "w" },
    left: { keyCode: 65, key: "a" },
    down: { keyCode: 83, key: "s" },
    right: { keyCode: 68, key: "d" },
    upLeft: { keys: [87, 65] },
    upRight: { keys: [87, 68] },
    downLeft: { keys: [83, 65] },
    downRight: { keys: [83, 68] }
};

// Create UI for visual feedback
function createVisualUI() {
    // Create container for the UI
    const uiContainer = document.createElement('div');
    uiContainer.id = 'bot-ui-container';
    uiContainer.style.cssText = `
        position: fixed;
        top: 10px;
        right: 10px;
        width: 250px;
        background-color: rgba(0, 0, 0, 0.7);
        color: white;
        padding: 10px;
        border-radius: 8px;
        font-family: Arial, sans-serif;
        z-index: 9999;
        user-select: none;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
    `;

    // Create header
    const header = document.createElement('div');
    header.innerHTML = 'Game Bot Controls';
    header.style.cssText = `
        font-size: 16px;
        font-weight: bold;
        margin-bottom: 10px;
        text-align: center;
        padding-bottom: 5px;
        border-bottom: 1px solid #555;
    `;
    uiContainer.appendChild(header);

    // Create status displays for each feature
    const features = [
        { id: 'movement-status', label: 'Move + Bombs (Z)', active: firstScriptActive },
        { id: 'respawn-status', label: 'Auto Respawn (X)', active: secondScriptActive },
        { id: 'bombspam-status', label: 'Bomb Chain (C)', active: false },
        { id: 'direction-status', label: 'Direction Active', active: false, direction: 'None' }
    ];

    features.forEach(feature => {
        const featureContainer = document.createElement('div');
        featureContainer.style.cssText = `
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            align-items: center;
        `;

        const label = document.createElement('span');
        label.textContent = feature.label;

        const status = document.createElement('span');
        status.id = feature.id;
        status.textContent = feature.active ? 'ON' : 'OFF';
        status.style.cssText = `
            font-weight: bold;
            color: ${feature.active ? '#4CAF50' : '#F44336'};
            background-color: rgba(0, 0, 0, 0.3);
            padding: 2px 6px;
            border-radius: 4px;
        `;

        featureContainer.appendChild(label);
        featureContainer.appendChild(status);
        uiContainer.appendChild(featureContainer);
    });

    // Add direction indicator
    const directionContainer = document.createElement('div');
    directionContainer.style.cssText = `
        margin-top: 10px;
        padding-top: 10px;
        border-top: 1px solid #555;
    `;

    const directionLabel = document.createElement('div');
    directionLabel.textContent = 'Current Direction:';
    directionLabel.style.marginBottom = '5px';
    directionContainer.appendChild(directionLabel);

    const directionIndicator = document.createElement('div');
    directionIndicator.id = 'direction-indicator';
    directionIndicator.style.cssText = `
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        grid-template-rows: repeat(3, 1fr);
        width: 90px;
        height: 90px;
        margin: 0 auto;
    `;

    // Create 3x3 grid for direction indicator
    for (let i = 0; i < 9; i++) {
        const cell = document.createElement('div');
        cell.style.cssText = `
            width: 30px;
            height: 30px;
            box-sizing: border-box;
            display: flex;
            align-items: center;
            justify-content: center;
        `;
        
        // Center cell is different
        if (i === 4) {
            cell.style.backgroundColor = '#444';
            cell.textContent = '⚪';
        } else {
            cell.style.border = '1px solid #333';
        }
        
        // Assign IDs to the cells that represent directions
        if (i === 0) cell.id = 'dir-up-left';
        if (i === 1) cell.id = 'dir-up';
        if (i === 2) cell.id = 'dir-up-right';
        if (i === 3) cell.id = 'dir-left';
        if (i === 5) cell.id = 'dir-right';
        if (i === 6) cell.id = 'dir-down-left';
        if (i === 7) cell.id = 'dir-down';
        if (i === 8) cell.id = 'dir-down-right';
        
        directionIndicator.appendChild(cell);
    }
    
    directionContainer.appendChild(directionIndicator);
    uiContainer.appendChild(directionContainer);

    // Add activity log
    const logContainer = document.createElement('div');
    logContainer.style.cssText = `
        margin-top: 10px;
        padding-top: 10px;
        border-top: 1px solid #555;
        max-height: 100px;
        overflow-y: auto;
    `;

    const logLabel = document.createElement('div');
    logLabel.textContent = 'Activity Log:';
    logLabel.style.marginBottom = '5px';
    logContainer.appendChild(logLabel);

    const logContent = document.createElement('div');
    logContent.id = 'bot-log';
    logContent.style.cssText = `
        font-size: 12px;
        color: #CCC;
    `;
    logContainer.appendChild(logContent);
    uiContainer.appendChild(logContainer);

    // Add minimize/maximize button
    const toggleButton = document.createElement('button');
    toggleButton.textContent = '−';
    toggleButton.style.cssText = `
        position: absolute;
        top: 5px;
        right: 5px;
        width: 20px;
        height: 20px;
        background: transparent;
        border: none;
        color: white;
        font-size: 16px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
    `;

    let minimized = false;
    const contentElements = [header, ...uiContainer.querySelectorAll('div:not(#bot-log)')];
    
    toggleButton.addEventListener('click', () => {
        minimized = !minimized;
        contentElements.forEach(el => {
            el.style.display = minimized ? 'none' : 'block';
        });
        toggleButton.textContent = minimized ? '+' : '−';
        uiContainer.style.height = minimized ? 'auto' : '';
    });
    
    uiContainer.appendChild(toggleButton);

    // Add the container to the document
    document.body.appendChild(uiContainer);
}

// Update UI status for a feature
function updateStatus(id, active, text = null) {
    const element = document.getElementById(id);
    if (element) {
        element.textContent = text || (active ? 'ON' : 'OFF');
        element.style.color = active ? '#4CAF50' : '#F44336';
    }
}

// Add message to the log
function logActivity(message) {
    const logElement = document.getElementById('bot-log');
    if (logElement) {
        const timestamp = new Date().toLocaleTimeString();
        const logItem = document.createElement('div');
        logItem.textContent = `[${timestamp}] ${message}`;
        logElement.prepend(logItem);
        
        // Limit number of log items
        if (logElement.children.length > 10) {
            logElement.removeChild(logElement.lastChild);
        }
    }
    console.log(message); // Still log to console as well
}

// Update direction indicator
function updateDirectionIndicator(direction) {
    // Reset all direction cells
    ['dir-up', 'dir-down', 'dir-left', 'dir-right', 
     'dir-up-left', 'dir-up-right', 'dir-down-left', 'dir-down-right'].forEach(id => {
        const cell = document.getElementById(id);
        if (cell) {
            cell.style.backgroundColor = '';
            cell.textContent = '';
        }
    });
    
    // Set active direction
    if (direction) {
        let dirId = null;
        
        if (direction === ee.up) dirId = 'dir-up';
        else if (direction === ee.down) dirId = 'dir-down';
        else if (direction === ee.left) dirId = 'dir-left';
        else if (direction === ee.right) dirId = 'dir-right';
        else if (direction === ee.upLeft) dirId = 'dir-up-left';
        else if (direction === ee.upRight) dirId = 'dir-up-right';
        else if (direction === ee.downLeft) dirId = 'dir-down-left';
        else if (direction === ee.downRight) dirId = 'dir-down-right';
        
        if (dirId) {
            const cell = document.getElementById(dirId);
            if (cell) {
                cell.style.backgroundColor = '#4CAF50';
                cell.textContent = '🔥';
            }
        }
    }
}

// First Script: Character Movement & Bomb Placement
function simulateKeyDown(direction) {
    if (typeof direction === 'number') {
        // Handle single keyCode input for the second script
        document.dispatchEvent(new KeyboardEvent("keydown", { keyCode: direction }));
        return;
    }
    
    if (direction.keys) {
        direction.keys.forEach(keyCode => {
            let event = new KeyboardEvent("keydown", { keyCode: keyCode });
            document.dispatchEvent(event);
        });
    } else {
        let event = new KeyboardEvent("keydown", { keyCode: direction.keyCode, key: direction.key });
        document.dispatchEvent(event);
    }
}

function simulateKeyUp(direction) {
    if (typeof direction === 'number') {
        // Handle single keyCode input for the second script
        document.dispatchEvent(new KeyboardEvent("keyup", { keyCode: direction }));
        return;
    }
    
    if (direction.keys) {
        direction.keys.forEach(keyCode => {
            let event = new KeyboardEvent("keyup", { keyCode: keyCode });
            document.dispatchEvent(event);
        });
    } else {
        let event = new KeyboardEvent("keyup", { keyCode: direction.keyCode, key: direction.key });
        document.dispatchEvent(event);
    }
}

// Function to simulate placing a bomb (pressing "K")
function placeBomb() {
    var bombKeyEvent = new KeyboardEvent("keydown", { keyCode: 75, key: "K" });
    document.dispatchEvent(bombKeyEvent);
    setTimeout(() => {
        var bombKeyReleaseEvent = new KeyboardEvent("keyup", { keyCode: 75, key: "K" });
        document.dispatchEvent(bombKeyReleaseEvent);
    }, 100);
    
    // Visual feedback - flash the bomb status
    const bombStatus = document.getElementById('movement-status');
    if (bombStatus) {
        bombStatus.style.backgroundColor = '#FFD700';
        setTimeout(() => {
            bombStatus.style.backgroundColor = 'rgba(0, 0, 0, 0.3)';
        }, 100);
    }
}

function getRandomDirection() {
    const directions = [ee.right, ee.down, ee.left, ee.up, ee.upLeft, ee.upRight, ee.downLeft, ee.downRight];
    return directions[Math.floor(Math.random() * directions.length)];
}

function getRandomDelay(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
}

function getRandomPause(min, max) {
    return Math.random() * (max - min) + min;
}

// Function to simulate random direction presses (W, A, S, D) for 50ms during pause
function randomDirectionPress() {
    const directions = [ee.up, ee.left, ee.down, ee.right];
    const direction = directions[Math.floor(Math.random() * directions.length)];
    // Simulate pressing a random direction key for 50ms
    simulateKeyDown(direction);
    setTimeout(() => {
        simulateKeyUp(direction); // Stop the key press after 50ms
    }, 50);
}

// Function to Move Character
function moveCharacter() {
    if (!firstScriptActive) return;
    const direction = getRandomDirection();
    const delay = getRandomDelay(900, 1500); // Longer motion time
    const pauseTime = getRandomPause(125, 1000);
    // If there's an ongoing movement, stop it before starting a new one
    if (moveTimeout) {
        clearTimeout(moveTimeout); // Clear the previous movement timeout
    }
    // Stop the current direction if it's moving
    if (currentDirection) {
        simulateKeyUp(currentDirection);
    }
    // Place a bomb before changing direction
    placeBomb();
    // Start the new movement direction after bomb placement
    currentDirection = direction;
    
    // Update the direction indicator in UI
    updateDirectionIndicator(direction);
    
    setTimeout(() => {
        simulateKeyDown(direction);
        moveTimeout = setTimeout(() => {
            simulateKeyUp(direction); // Stop the current movement after delay
            
            // Simulate random direction press during the pause (50ms)
            randomDirectionPress();
            
            setTimeout(moveCharacter, pauseTime); // Pause before next movement
        }, delay);
    }, 100); // Wait 100ms for bomb placement before moving
}

function simulateSpaceKeyPress() {
    if (!firstScriptActive) return;
    var spaceKeyEvent = new KeyboardEvent("keydown", { keyCode: 32, key: " " });
    document.dispatchEvent(spaceKeyEvent);
    setTimeout(() => {
        var spaceKeyReleaseEvent = new KeyboardEvent("keyup", { keyCode: 32, key: " " });
        document.dispatchEvent(spaceKeyReleaseEvent);
    }, 100);
}

// Second Script: Auto Respawn and R key press
function startAutoRespawn() {
    // Clear any existing interval first to prevent multiple instances
    if (scoreBoardInterval) {
        clearInterval(scoreBoardInterval);
    }
    
    scoreBoardInterval = setInterval(() => {
        if (!secondScriptActive) return;
        
        const scoreboard = document.getElementById("scoreboard-new");
        if (scoreboard && scoreboard.offsetParent === null) {
            // not visible
            return;
        }
        
        const respawnButton = [...document.getElementsByTagName("button")]
            .filter(b => b.innerText.indexOf("Respawn [Space]") === 0)[0];
        
        if (respawnButton) {
            // Clear any existing timer
            if (respawnTimer) clearTimeout(respawnTimer);
            
            // Click the respawn button
            respawnButton.click();
            logActivity("Автоматический респавн активирован");
            
            // Flash UI feedback
            const respawnStatus = document.getElementById('respawn-status');
            if (respawnStatus) {
                respawnStatus.style.backgroundColor = '#FFD700';
                setTimeout(() => {
                    respawnStatus.style.backgroundColor = 'rgba(0, 0, 0, 0.3)';
                }, 300);
            }
            
            // Set timer to press R after respawn
            respawnTimer = setTimeout(() => {
                logActivity("Нажата клавиша R");
                
                // Simulate R keypress
                const rKeyDown = new KeyboardEvent('keydown', { key: 'r', code: 'KeyR', keyCode: 82, which: 82 });
                document.dispatchEvent(rKeyDown);
                
                // Release R key after a short delay
                setTimeout(() => {
                    const rKeyUp = new KeyboardEvent('keyup', { key: 'r', code: 'KeyR', keyCode: 82, which: 82 });
                    document.dispatchEvent(rKeyUp);
                }, 50);
            }, 1000); // 1 second after respawn
        }
    }, 100);
}

// Third Script: Bomb Spam when C is held
function startBombSpam() {
    // If an interval is already running, don't create a new one
    if (bombSpamInterval) return;
    
    // Create a rapid interval to spam bombs (K key)
    bombSpamInterval = setInterval(() => {
        if (bombSpamActive) {
            // Simulate K keypress (place bomb) as fast as possible
            var bombKeyEvent = new KeyboardEvent("keydown", { keyCode: 75, key: "k" });
            document.dispatchEvent(bombKeyEvent);
            
            // Flash UI feedback (less frequently to avoid performance issues)
            if (Math.random() < 0.2) { // Only flash for ~20% of bombs
                const bombSpamStatus = document.getElementById('bombspam-status');
                if (bombSpamStatus) {
                    bombSpamStatus.style.backgroundColor = '#FFD700';
                    setTimeout(() => {
                        bombSpamStatus.style.backgroundColor = 'rgba(0, 0, 0, 0.3)';
                    }, 20);
                }
            }
            
            // Release K key immediately
            setTimeout(() => {
                var bombKeyReleaseEvent = new KeyboardEvent("keyup", { keyCode: 75, key: "k" });
                document.dispatchEvent(bombKeyReleaseEvent);
            }, 10); // Very short delay for rapid spam
        }
    }, 20); // 20ms interval for very fast bomb spam (close to 50 times per second)
}

// Stop bomb spam
function stopBombSpam() {
    if (bombSpamInterval) {
        clearInterval(bombSpamInterval);
        bombSpamInterval = null;
    }
}

// Fourth Script: Directional bombing with held keys
// Function to hold down keys
function holdKeys(keys) {
    keys.forEach(key => simulateKeyDown(key));
}

// Function to release all held keys
function releaseAllKeys() {
    [87, 65, 83, 68].forEach(key => simulateKeyUp(key)); // Release "W", "A", "S", "D"
    updateDirectionIndicator(null); // Reset direction indicator
}

// Function to start actions when enabled (bomb spamming)
function startBombAction() {
    logActivity("Направленное движение с бомбами активировано");
    bombInterval = setInterval(() => {
        if (!active) {
            clearInterval(bombInterval);
            return;
        }
        simulateKeyDown(75); // "K" key (Bomb)
        
        // Flash UI feedback (less frequently)
        if (Math.random() < 0.2) {
            const directionStatus = document.getElementById('direction-status');
            if (directionStatus) {
                directionStatus.style.backgroundColor = '#FFD700';
                setTimeout(() => {
                    directionStatus.style.backgroundColor = 'rgba(0, 0, 0, 0.3)';
                }, 20);
            }
        }
        
        setTimeout(() => simulateKeyUp(75), 50);
    }, 100); // Spams "K" key every 100ms
}

// Function to stop everything when disabled
function stopBombAction() {
    logActivity("Направленное движение с бомбами деактивировано");
    clearInterval(bombInterval); // Stop bomb spamming
}

// Initialize UI
function initializeScript() {
    // Create the visual UI
    createVisualUI();
    
    // Initialize auto-respawn (second script)
    startAutoRespawn();
    
    // Initialize bomb spam capability
    startBombSpam();
    
    // Update initial status
    updateStatus('movement-status', firstScriptActive);
    updateStatus('respawn-status', secondScriptActive);
    updateStatus('bombspam-status', bombSpamActive);
    updateStatus('direction-status', false, 'None');
    
    // Log initial state
    logActivity("Скрипт успешно загружен!");
    logActivity("Движения бота + респавн (Z): " + (firstScriptActive ? "Включено" : "Отключено"));
    logActivity("Тыква + респавн (X): " + (secondScriptActive ? "Включено" : "Отключено"));
    logActivity("Авто Цепь (держать C): Готово");
    logActivity("Направленное движение с бомбами (Y/U/H/J): Готово");
}

// Toggle scripts with Z and X keys, hold C for bomb spam
document.addEventListener("keydown", (event) => {
    // Toggle first script (character movement) with Z key
    if (event.key === "z" || event.key === "Z") {
        firstScriptActive = !firstScriptActive;
        updateStatus('movement-status', firstScriptActive);
        logActivity(`Движения бота + респавн ${firstScriptActive ? "включено" : "отключено"}`);
        if (firstScriptActive) {
            moveCharacter(); // Restart movement loop when re-enabled
        } else {
            // Clear direction when disabled
            if (currentDirection) {
                simulateKeyUp(currentDirection);
                currentDirection = null;
                updateDirectionIndicator(null);
            }
        }
    }
    
    // Toggle second script (auto-respawn) with X key
    if (event.key === "x" || event.key === "X") {
        secondScriptActive = !secondScriptActive;
        updateStatus('respawn-status', secondScriptActive);
        logActivity(`Тыква + респавн ${secondScriptActive ? "включено" : "отключено"}`);
        if (secondScriptActive && !scoreBoardInterval) {
            startAutoRespawn(); // Restart auto-respawn if needed
        }
    }
    
    // Activate bomb spam when C is pressed
    if (event.key === "c" || event.key === "C") {
        bombSpamActive = true;
        updateStatus('bombspam-status', true);
        logActivity("Авто цепь активирована");
    }
    
    // Fourth script directional controls
    if (isToggling) return; // Prevent multiple rapid key presses
    isToggling = true;
    
    if (event.key === "y" || event.key === "Y") {
        releaseAllKeys(); // Release any previously held keys
        holdKeys([87, 65]); // Hold "W" and "A"
        active = true;
        updateStatus('direction-status', true, 'UP-LEFT');
        updateDirectionIndicator(ee.upLeft);
        startBombAction(); // Start bomb spamming
    } else if (event.key === "u" || event.key === "U") {
        releaseAllKeys(); // Release any previously held keys
        holdKeys([87, 68]); // Hold "W" and "D"
        active = true;
        updateStatus('direction-status', true, 'UP-RIGHT');
        updateDirectionIndicator(ee.upRight);
        startBombAction(); // Start bomb spamming
    } else if (event.key === "h" || event.key === "H") {
        releaseAllKeys(); // Release any previously held keys
        holdKeys([65, 83]); // Hold "A" and "S"
        active = true;
        updateStatus('direction-status', true, 'DOWN-LEFT');
        updateDirectionIndicator(ee.downLeft);
        startBombAction(); // Start bomb spamming
    } else if (event.key === "j" || event.key === "J") {
        releaseAllKeys(); // Release any previously held keys
        holdKeys([83, 68]); // Hold "S" and "D"
        active = true;
        updateStatus('direction-status', true, 'DOWN-RIGHT');
        updateDirectionIndicator(ee.downRight);
        startBombAction(); // Start bomb spamming
    }
    
    // Prevent fast toggling
    setTimeout(() => {
        isToggling = false;
    }, 100);
});

// Event listener for key releases
document.addEventListener("keyup", (event) => {
    // Stop bomb spam when C is released
    if (event.key === "c" || event.key === "C") {
        bombSpamActive = false;
        updateStatus('bombspam-status', false);
        logActivity("Авто цепь деактивирована");
    }
    
    // Fourth script key releases
    if (event.key === "y" || event.key === "Y") {
        active = false;
        releaseAllKeys(); // Release "W" and "A" when "Y" is released
        updateStatus('direction-status', false, 'None');
        stopBombAction(); // Stop bomb spamming
    } else if (event.key === "u" || event.key === "U") {
        active = false;
        releaseAllKeys(); // Release "W" and "D" when "U" is released
        updateStatus('direction-status', false, 'None');
        stopBombAction(); // Stop bomb spamming
    } else if (event.key === "h" || event.key === "H") {
        active = false;
        releaseAllKeys(); // Release "A" and "S" when "H" is released
        updateStatus('direction-status', false, 'None');
        stopBombAction(); // Stop bomb spamming
    } else if (event.key === "j" || event.key === "J") {
        active = false;
        releaseAllKeys(); // Release "S" and "D" when "J" is released
        updateStatus('direction-status', false, 'None');
        stopBombAction(); // Stop bomb spamming
    }
});

// Initialize the script with UI
initializeScript();
